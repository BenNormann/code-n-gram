Branch Name,Commit Hash,File Name,Method Name,Method Code,Commit Link
master,726f5fc7464b6ebeb4accc8ff2816e375425a383,cleanup.py,rep,"def rep(m):
	if m.group(1) in FUNCS:
		print(m.group(1)
)
		return m.group(0)
	return ''",https://www.github.com/cesena/ghidra2dwarf/commit/726f5fc7464b6ebeb4accc8ff2816e375425a383
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,read_byte,"def read_byte(sock):
    return ord(sock.recv(1))",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,write_byte,"def write_byte(sock, b):
    return sock.send(chr(b))",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,read_packet,"def read_packet(sock):
    toread = struct.unpack('<l', sock.recv(4))[0]
    buf = bytearray(toread)
    view = memoryview(buf)
    while toread:
        nbytes = sock.recv_into(view, toread)
        view = view[nbytes:]
        toread -= nbytes
    return buf",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,write_packet,"def write_packet(sock, msg):
    sock.sendall(struct.pack('<l', len(msg)))
    return sock.sendall(msg)",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,crypt_pwd,"def crypt_pwd(pwd, x):
    return ''.join(chr(b ^ x) for b in bytearray(pwd))",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,__init__,"    def __init__(self):
        server_address = ('localhost', 6666)
        sock = self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(server_address)
        b = read_byte(sock)
        write_packet(sock, crypt_pwd(PWD.encode(), b).encode())",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,repl,"    def repl(self, code):
        sock = self.sock
        write_packet(sock, code.encode())
        out = read_packet(sock)
        return bytes(out).decode()",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,a09e41ca743248e97141b6c391bd85884df7a441,repl.py,kill,"    def kill(self):
        self.sock.close()",https://www.github.com/cesena/ghidra2dwarf/commit/a09e41ca743248e97141b6c391bd85884df7a441
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,kernel.py,__init__,"    def __init__(self, **kwargs):
        IPythonKernel.__init__(self, **kwargs)

        self.jython = None
        self._init_jython()",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,kernel.py,_init_jython,"    def _init_jython(self):
        ''' Initialize Ghidra's Jython interpreter. '''

        sig = signal.signal(signal.SIGINT, signal.SIG_DFL)
        try:
           self.jython = GhidraJythonRepl()
        finally:
            signal.signal(signal.SIGINT, sig)",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,kernel.py,execution_count,"    def execution_count(self):
        return Kernel.execution_count",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,kernel.py,execution_count,"    def execution_count(self, value):
        Kernel.execution_count = value",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,kernel.py,do_execute,"    def do_execute(self, code, silent, store_history=True, user_expressions=None, allow_stdin=False):
        if not silent:
            stream_content = {'name': 'stdout', 'text': self.jython.repl(code)}
            self.send_response(self.iopub_socket, 'stream', stream_content)

        return {
            'status': 'ok',
            'execution_count': Kernel.execution_count,
            'payload': [],
            'user_expressions': {}
        }",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,kernel.py,do_shutdown,"    def do_shutdown(self, restart):
        self.jython.kill()
        IPythonKernel.do_shutdown(self, restart)
        return {
            'status':'ok',
            'restart': restart
        }",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,read_byte,"def read_byte(sock):
    return ord(sock.recv(1))",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,write_byte,"def write_byte(sock, b):
    return sock.send(chr(b))",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,read_packet,"def read_packet(sock):
    toread = struct.unpack('<l', sock.recv(4))[0]
    buf = bytearray(toread)
    view = memoryview(buf)
    while toread:
        nbytes = sock.recv_into(view, toread)
        view = view[nbytes:]
        toread -= nbytes
    return buf",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,write_packet,"def write_packet(sock, msg):
    sock.sendall(struct.pack('<l', len(msg)))
    return sock.sendall(msg)",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,crypt_pwd,"def crypt_pwd(pwd, x):
    return bytearray(b ^ x for b in bytearray(pwd))",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,__init__,"    def __init__(self):
        server_address = ('localhost', 6666)
        sock = self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(server_address)
        b = read_byte(sock)
        write_packet(sock, crypt_pwd(PWD.encode(), b))",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,repl,"    def repl(self, code):
        sock = self.sock
        write_packet(sock, code.encode())
        out = read_packet(sock)
        return bytes(out).decode()",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181,repl.py,kill,"    def kill(self):
        self.sock.close()",https://www.github.com/cesena/ghidra2dwarf/commit/43a8b56f775b0afe88cc7cecfbf6b9f9cb76e181
master,e74b4bd2c7d184402e5f040dda07ca59bfc8b78a,dwarfexport.py,add_debug_info,"def add_debug_info(info):
    dbg = info.dbg
    err = info.err
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    dwarf_add_AT_name(cu, curr.name + "".c"", info.err)
    dir_index = dwarf_add_directory_decl(dbg, curr.name + "".dbg"", err)
    file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
    print(dir_index)
    print(file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/e74b4bd2c7d184402e5f040dda07ca59bfc8b78a
master,e74b4bd2c7d184402e5f040dda07ca59bfc8b78a,dwarfexport.py,__init__,"    def __init__(self):
        self.elf = 0
        self.mode = 8
        self.dbg = PointerByReference()
        self.err = PointerByReference()
        dwarf_producer_init(
            DW_DLC_WRITE
            | DW_DLC_SYMBOLIC_RELOCATIONS
            | DW_DLC_POINTER64
            | DW_DLC_OFFSET32
            | DW_DLC_TARGET_LITTLEENDIAN,
            lambda x: 0,
            None,
            None,
            None,
            ""x86_64"",
            ""V2"",
            None,
            self.dbg,
            self.err,
        )
        self.dbg = Dwarf_P_Debug(self.dbg.value)",https://www.github.com/cesena/ghidra2dwarf/commit/e74b4bd2c7d184402e5f040dda07ca59bfc8b78a
master,458a02307a310c90cae6f763646367d1d5758726,dwarfexport.py,add_debug_info,"def add_debug_info(info):
    dbg = info.dbg
    err = info.err
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    dwarf_add_AT_name(cu, ext_c(curr.name), info.err)
    dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
    file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
    print(dir_index)
    print(file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/458a02307a310c90cae6f763646367d1d5758726
master,458a02307a310c90cae6f763646367d1d5758726,dwarfexport.py,__init__,"    def __init__(self):
        self.elf = 0
        self.mode = 8
        self.dbg = PointerByReference()
        self.err = PointerByReference()
        dwarf_producer_init(
            DW_DLC_WRITE
            | DW_DLC_SYMBOLIC_RELOCATIONS
            | DW_DLC_POINTER64
            | DW_DLC_OFFSET32
            | DW_DLC_TARGET_LITTLEENDIAN,
            lambda x: 0,
            None,
            None,
            None,
            ""x86_64"",
            ""V2"",
            None,
            self.dbg,
            self.err,
        )
        self.dbg = Dwarf_P_Debug(self.dbg.value)",https://www.github.com/cesena/ghidra2dwarf/commit/458a02307a310c90cae6f763646367d1d5758726
master,1c0230e9d4b8bd0b9137f6fd16c8c63423b66a3b,dwarfexport.py,add_debug_info,"def add_debug_info(info):
    dbg = info.dbg
    err = info.err
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    dwarf_add_AT_name(cu, ext_c(curr.name), info.err)
    dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
    file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
    print(dir_index)
    print(file_index)
    # dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    ifc = DecompInterface()
    ifc.openProgram(curr)
    fm = curr.getFunctionManager()
    funcs = fm.getFunctions(True)
    for f in funcs:
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/1c0230e9d4b8bd0b9137f6fd16c8c63423b66a3b
master,1c0230e9d4b8bd0b9137f6fd16c8c63423b66a3b,dwarfexport.py,__init__,"    def __init__(self):
        self.elf = 0
        self.mode = 8
        self.dbg = PointerByReference()
        self.err = PointerByReference()
        dwarf_producer_init(
            DW_DLC_WRITE
            | DW_DLC_SYMBOLIC_RELOCATIONS
            | DW_DLC_POINTER64
            | DW_DLC_OFFSET32
            | DW_DLC_TARGET_LITTLEENDIAN,
            lambda x: 0,
            None,
            None,
            None,
            ""x86_64"",
            ""V2"",
            None,
            self.dbg,
            self.err,
        )
        self.dbg = Dwarf_P_Debug(self.dbg.value)",https://www.github.com/cesena/ghidra2dwarf/commit/1c0230e9d4b8bd0b9137f6fd16c8c63423b66a3b
master,65d115225b73b207828d251c630e24f750d5f6dc,dwarfexport.py,add_debug_info,"def add_debug_info(info):
    dbg = info.dbg
    err = info.err
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    dwarf_add_AT_name(cu, ext_c(curr.name), info.err)
    dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
    file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
    print(dir_index)
    print(file_index)
    dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    ifc = DecompInterface()
    ifc.openProgram(curr)
    fm = curr.getFunctionManager()
    funcs = fm.getFunctions(True)
    for f in funcs:
        add_function(info, cu, f, 1, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/65d115225b73b207828d251c630e24f750d5f6dc
master,65d115225b73b207828d251c630e24f750d5f6dc,dwarfexport.py,add_function,"def add_function(info, cu, func, linecount, file_index):
    dbg = info.dbg
    err = info.err
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == linecount - 1:
        print(""error"")",https://www.github.com/cesena/ghidra2dwarf/commit/65d115225b73b207828d251c630e24f750d5f6dc
master,65d115225b73b207828d251c630e24f750d5f6dc,dwarfexport.py,__init__,"    def __init__(self):
        self.elf = 0
        self.mode = 8
        self.dbg = PointerByReference()
        self.err = PointerByReference()
        dwarf_producer_init(
            DW_DLC_WRITE
            | DW_DLC_SYMBOLIC_RELOCATIONS
            | DW_DLC_POINTER64
            | DW_DLC_OFFSET32
            | DW_DLC_TARGET_LITTLEENDIAN,
            lambda x: 0,
            None,
            None,
            None,
            ""x86_64"",
            ""V2"",
            None,
            self.dbg,
            self.err,
        )
        self.dbg = Dwarf_P_Debug(self.dbg.value)",https://www.github.com/cesena/ghidra2dwarf/commit/65d115225b73b207828d251c630e24f750d5f6dc
master,5458523c6cefe4b52a19e8c61c37f7e0036df626,dwarfexport.py,add_debug_info,"def add_debug_info(info):
    dbg = info.dbg
    err = info.err
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    dwarf_add_AT_name(cu, ext_c(curr.name), info.err)
    dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
    file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
    print(dir_index)
    print(file_index)
    dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    ifc = DecompInterface()
    ifc.openProgram(curr)
    fm = curr.getFunctionManager()
    funcs = fm.getFunctions(True)
    for f in funcs:
        add_function(info, cu, f, 1, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/5458523c6cefe4b52a19e8c61c37f7e0036df626
master,5458523c6cefe4b52a19e8c61c37f7e0036df626,dwarfexport.py,add_function,"def add_function(info, cu, func, linecount, file_index):
    dbg = info.dbg
    err = info.err
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == linecount - 1:
        print(""error"")",https://www.github.com/cesena/ghidra2dwarf/commit/5458523c6cefe4b52a19e8c61c37f7e0036df626
master,5458523c6cefe4b52a19e8c61c37f7e0036df626,dwarfexport.py,__init__,"    def __init__(self):
        self.elf = 0
        self.mode = 8
        self.dbg = PointerByReference()
        self.err = PointerByReference()
        dwarf_producer_init(
            DW_DLC_WRITE
            | DW_DLC_SYMBOLIC_RELOCATIONS
            | DW_DLC_POINTER64
            | DW_DLC_OFFSET32
            | DW_DLC_TARGET_LITTLEENDIAN,
            lambda x: 0,
            None,
            None,
            None,
            ""x86_64"",
            ""V2"",
            None,
            self.dbg,
            self.err,
        )
        self.dbg = Dwarf_P_Debug(self.dbg.value)",https://www.github.com/cesena/ghidra2dwarf/commit/5458523c6cefe4b52a19e8c61c37f7e0036df626
master,5458523c6cefe4b52a19e8c61c37f7e0036df626,dwarfexport.py,__init__,"    def __init__(
        self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False
    ):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/5458523c6cefe4b52a19e8c61c37f7e0036df626
master,61b019a5f875d1b17dafd2c09e773a8429f2eab8,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    dwarf_add_AT_name(cu, ext_c(curr.name), err)
    dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
    file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
    print(dir_index)
    print(file_index)
    dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    ifc = DecompInterface()
    ifc.openProgram(curr)
    fm = curr.getFunctionManager()
    funcs = fm.getFunctions(True)
    for f in funcs:
        add_function(cu, f, 1, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/61b019a5f875d1b17dafd2c09e773a8429f2eab8
master,61b019a5f875d1b17dafd2c09e773a8429f2eab8,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == linecount - 1:
        print(""error"")",https://www.github.com/cesena/ghidra2dwarf/commit/61b019a5f875d1b17dafd2c09e773a8429f2eab8
master,61b019a5f875d1b17dafd2c09e773a8429f2eab8,dwarfexport.py,__init__,"    def __init__(
        self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False
    ):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/61b019a5f875d1b17dafd2c09e773a8429f2eab8
master,4ee7d98becfba0a1ec80932e7bef4fed53f0f399,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    ifc = DecompInterface()
    ifc.openProgram(curr)
    fm = curr.getFunctionManager()
    funcs = fm.getFunctions(True)
    for f in funcs:
        add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/4ee7d98becfba0a1ec80932e7bef4fed53f0f399
master,4ee7d98becfba0a1ec80932e7bef4fed53f0f399,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == linecount - 1:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    print(f_name)
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")",https://www.github.com/cesena/ghidra2dwarf/commit/4ee7d98becfba0a1ec80932e7bef4fed53f0f399
master,4ee7d98becfba0a1ec80932e7bef4fed53f0f399,dwarfexport.py,__init__,"    def __init__(
        self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False
    ):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/4ee7d98becfba0a1ec80932e7bef4fed53f0f399
master,7ae96c54f50bc77f5ccac7e73a8853b0441b1367,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    ifc = DecompInterface()
    ifc.openProgram(curr)
    fm = curr.getFunctionManager()
    funcs = fm.getFunctions(True)
    for f in funcs:
        add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/7ae96c54f50bc77f5ccac7e73a8853b0441b1367
master,7ae96c54f50bc77f5ccac7e73a8853b0441b1367,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == linecount - 1:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    print(f_name)
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    # if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
    #     stderr.write(""dwarf_add_AT_string error"")

    # NOT Working, I don't know why https://github.com/NationalSecurityAgency/ghidra/issues/835
    f_start = func.getEntryPoint()
    f_end = func.getBody().getMaxAddress()
    print(f_start)
    print(f_end)",https://www.github.com/cesena/ghidra2dwarf/commit/7ae96c54f50bc77f5ccac7e73a8853b0441b1367
master,7ae96c54f50bc77f5ccac7e73a8853b0441b1367,dwarfexport.py,__init__,"    def __init__(
        self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False
    ):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/7ae96c54f50bc77f5ccac7e73a8853b0441b1367
master,be52a0f7d29c54655e0c4160659984902c06fcc7,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    ifc = DecompInterface()
    ifc.openProgram(curr)
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    for f in funcs:
        add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/be52a0f7d29c54655e0c4160659984902c06fcc7
master,be52a0f7d29c54655e0c4160659984902c06fcc7,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    print(f_name)
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start = func.entryPoint
    f_end = func.body.maxAddress
    print(f_start)
    print(f_end)
    print(""\n"")",https://www.github.com/cesena/ghidra2dwarf/commit/be52a0f7d29c54655e0c4160659984902c06fcc7
master,be52a0f7d29c54655e0c4160659984902c06fcc7,dwarfexport.py,__init__,"    def __init__(
        self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False
    ):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/be52a0f7d29c54655e0c4160659984902c06fcc7
master,5d52835e754d3793886467218b5385b2098156ea,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/5d52835e754d3793886467218b5385b2098156ea
master,5d52835e754d3793886467218b5385b2098156ea,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/5d52835e754d3793886467218b5385b2098156ea
master,5d52835e754d3793886467218b5385b2098156ea,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/5d52835e754d3793886467218b5385b2098156ea
master,5d52835e754d3793886467218b5385b2098156ea,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    print(f_name)
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    print(f_start)
    print(f_end)
    print(""\n"")",https://www.github.com/cesena/ghidra2dwarf/commit/5d52835e754d3793886467218b5385b2098156ea
master,5d52835e754d3793886467218b5385b2098156ea,dwarfexport.py,__init__,"    def __init__(
        self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False
    ):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/5d52835e754d3793886467218b5385b2098156ea
master,9e752dede6d36920e7376f5e4df8e4d1bb17d210,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/9e752dede6d36920e7376f5e4df8e4d1bb17d210
master,9e752dede6d36920e7376f5e4df8e4d1bb17d210,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/9e752dede6d36920e7376f5e4df8e4d1bb17d210
master,9e752dede6d36920e7376f5e4df8e4d1bb17d210,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/9e752dede6d36920e7376f5e4df8e4d1bb17d210
master,9e752dede6d36920e7376f5e4df8e4d1bb17d210,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    print(f_name)
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.getExecuteSet().getAddressRanges():
        if (
            f_start.offset >= s.minAddress.offset
            and f_end.offset <= s.maxAddress.offset
        ):
            print(f_start)
            print(f_end)
            print(func.returnType.description)
            print(""\n"")",https://www.github.com/cesena/ghidra2dwarf/commit/9e752dede6d36920e7376f5e4df8e4d1bb17d210
master,9e752dede6d36920e7376f5e4df8e4d1bb17d210,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer, Why?
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/9e752dede6d36920e7376f5e4df8e4d1bb17d210
master,9e752dede6d36920e7376f5e4df8e4d1bb17d210,dwarfexport.py,__init__,"    def __init__(
        self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False
    ):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/9e752dede6d36920e7376f5e4df8e4d1bb17d210
master,74afdb11427d189f1419a20805ea062d14739ef4,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/74afdb11427d189f1419a20805ea062d14739ef4
master,74afdb11427d189f1419a20805ea062d14739ef4,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/74afdb11427d189f1419a20805ea062d14739ef4
master,74afdb11427d189f1419a20805ea062d14739ef4,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/74afdb11427d189f1419a20805ea062d14739ef4
master,74afdb11427d189f1419a20805ea062d14739ef4,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    # I don't know if it is linecount - 1 or what
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            print(f_start, f_end, func.returnType.description)",https://www.github.com/cesena/ghidra2dwarf/commit/74afdb11427d189f1419a20805ea062d14739ef4
master,74afdb11427d189f1419a20805ea062d14739ef4,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer, Why?
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/74afdb11427d189f1419a20805ea062d14739ef4
master,74afdb11427d189f1419a20805ea062d14739ef4,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/74afdb11427d189f1419a20805ea062d14739ef4
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(False)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, s.PCAddress, hv.dataType, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, addr, datatype, storage in get_decompiled_variables(decomp):
        print(name, addr, datatype, storage)

    cmarkup = decomp.CCodeMarkup
    l = []
    cmarkup.flatten(l)
    for x in l:
        # print(x.numChildren)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            print(f_start, f_end, func.returnType.description)",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer, Why?
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,add_struct_type,"def add_struct_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, t.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,c8c9d930b65ee4e36a801b71b81b5fe082db6132,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/c8c9d930b65ee4e36a801b71b81b5fe082db6132
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(False)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, s.PCAddress, hv.dataType, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, addr, datatype, storage in get_decompiled_variables(decomp):
        print(name, addr, datatype, storage)

    cmarkup = decomp.CCodeMarkup
    l = []
    cmarkup.flatten(l)
    for x in l:
        # print(x.numChildren)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            t = func.returnType
            print(f_start, f_end, func.returnType.description, func.name)",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer, Why?
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,add_struct_type,"def add_struct_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, t.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    for s in curr.dataTypeManager.allStructures:
        if s.name == t.name:
            for x in a.components:
                # add_type(x.dataType)
                pass",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,420d22db2c494672670f7b0dee6fb466bde6dff1,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/420d22db2c494672670f7b0dee6fb466bde6dff1
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(False)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, s.PCAddress, hv.dataType, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, addr, datatype, storage in get_decompiled_variables(decomp):
        print(name, addr, datatype, storage)

    cmarkup = decomp.CCodeMarkup
    l = []
    cmarkup.flatten(l)
    for x in l:
        # print(x.numChildren)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            t = func.returnType
            print(f_start, f_end, func.returnType.description, func.name)",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer, Why?
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,add_struct_type,"def add_struct_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, t.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    for c in t.dataType.components:
        print(c.dataType)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,862ca123b3d502123dd977c73e1a726cf83a6a59,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/862ca123b3d502123dd977c73e1a726cf83a6a59
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        print(name, datatype, addr, storage)
        # add_variable(cu, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        print(lowest_addr, l)",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func, 0)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            t = func.returnType",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer, Why?
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,add_struct_type,"def add_struct_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, t.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    for c in t.dataType.components:
        print(c.dataType)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,783f819dc472cef0ac7f724ff66b1a3edeb011e3,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/783f819dc472cef0ac7f724ff66b1a3edeb011e3
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        add_function(cu, f, linecount, file_index)",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        pass
        #print(name, datatype, addr, storage)
        # add_variable(cu, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func, 0)
    # TODO: WTF is this shit
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            t = func.returnType
            #print(f_start, f_end, type(t), t.description, func.name)
    add_type(cu, func.returnType)",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        #print(type(t), t)
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`
        return None
    elif isinstance(t, BuiltInDataType):
        # TODO: an example of BuiltInDataType is `int`
        return None
    elif isinstance(t, Structure):
        #print(type(t), t)
        return add_struct_type(cu, t)
    else:
        raise Exception(('ERR type:', type(t), t))
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        #print(c.dataType)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,d95447436477704352c75c0fdd2dc52220b3abe6,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/d95447436477704352c75c0fdd2dc52220b3abe6
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        pass
        # print(name, datatype, addr, storage)
        # add_variable(cu, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func, 0)

    t = func.returnType
    print(f_start, f_end, type(t), t.description, func.name)
    add_type(cu, func.returnType)",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        # print(type(t), t)
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`
        return None
    elif isinstance(t, BuiltInDataType):
        # TODO: an example of BuiltInDataType is `int`
        return None
    elif isinstance(t, Structure):
        # print(type(t), t)
        return add_struct_type(cu, t)
    else:
        raise Exception((""ERR type:"", type(t), t))
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    # TODO: Add without pointer
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, )
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        # print(c.dataType)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,022dff4072df734cc5b631a30388eb92fe98d53b,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/022dff4072df734cc5b631a30388eb92fe98d53b
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        pass
        # print(name, datatype, addr, storage)
        # add_variable(cu, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func, 0)

    t = func.returnType
    print(f_start, f_end, type(t), t.description, func.name)
    add_type(cu, func.returnType)",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        # print(type(t), t)
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`
        return None
    elif isinstance(t, BuiltInDataType):
        # TODO: an example of BuiltInDataType is `int`
        return None
    elif isinstance(t, Structure):
        # print(type(t), t)
        return add_struct_type(cu, t)
    else:
        try:
            die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
            dwarf_add_AT_name(die, type.name, err)
            dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, type.length, err)
            return die
        except:
            raise Exception((""ERR type:"", type(t), t))
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) == None:
        stderr.write(""dwarf_add_AT_reference child error"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        # print(c.dataType)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/d577cc1b2726c99ab6ce6a3f2c0be0f9fe42aa11
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        pass
        # print(name, datatype, addr, storage)
        # add_variable(cu, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func, 0)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    add_type(cu, func.returnType)",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        # print(type(t), t)
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`
        return None
    elif isinstance(t, BuiltInDataType):
        # TODO: an example of BuiltInDataType is `int`
        return None
    elif isinstance(t, Structure):
        # print(type(t), t)
        return add_struct_type(cu, t)
    else:
        try:
            die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
            dwarf_add_AT_name(die, type.name, err)
            dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, type.length, err)
            return die
        except:
            raise Exception((""ERR type:"", type(t), t))
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) == None:
        stderr.write(""dwarf_add_AT_reference child error"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            stderr.write(""dward_add_expr_gen error"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) == None:
            stderr.write(""dwarf_add_AT_location_expr error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,1c812e0cbe839d7a0de44442c8d5fcfb928e38ac,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/1c812e0cbe839d7a0de44442c8d5fcfb928e38ac
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        pass
        # print(name, datatype, addr, storage)
        # add_variable(cu, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func, 0)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        # print(type(t), t)
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`
        return None
    elif isinstance(t, BuiltInDataType):
        # TODO: an example of BuiltInDataType is `int`
        return None
    elif isinstance(t, Structure):
        # print(type(t), t)
        return add_struct_type(cu, t)
    else:
        try:
            die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
            dwarf_add_AT_name(die, type.name, err)
            dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, type.length, err)
            return die
        except:
            raise Exception((""ERR type:"", type(t), t))
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) == None:
        stderr.write(""dwarf_add_AT_reference child error"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            stderr.write(""dward_add_expr_gen error"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) == None:
            stderr.write(""dwarf_add_AT_location_expr error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,a4d6dd6761931023c1ba18d0cac103073b8a965a,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/a4d6dd6761931023c1ba18d0cac103073b8a965a
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        pass
        # print(name, datatype, addr, storage)
        # add_variable(cu, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name == ""main"":
        add_decompiler_func_info(cu, die, func, 0)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            raise Exception((""ERR type:"", type(t), t))
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) == None:
        stderr.write(""dwarf_add_AT_reference child error"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            stderr.write(""dward_add_expr_gen error"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) == None:
            stderr.write(""dwarf_add_AT_location_expr error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,2ea2db2e02daea53913a98251da169943a648b84,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/2ea2db2e02daea53913a98251da169943a648b84
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) == None:
            stderr.write(""dwarf_add_AT_name error"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()['DW_OP_breg%d' % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    print(name, datatype, addr, storage)

    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err);
    type_die = add_type(cu, datatype)

    at_ref = dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err)
    assert at_ref is not None, ""dwarf_add_AT_reference failed: "" + get_libdwarf_err()

    at_name = dwarf_add_AT_name(var_die, name, err)
    assert at_name is not None, ""dwarf_add_AT_name failed: "" + get_libdwarf_err()

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        add_expr = dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err)
        assert add_expr != DW_DLV_NOCOUNT, ""dwarf_add_expr_gen failed: "" + get_libdwarf_err()
        print('reg', varnode, reg, reg.offset)
    elif varnode_addr.isStackAddress():
        add_expr = dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err)
        assert add_expr != DW_DLV_NOCOUNT, ""dwarf_add_expr_gen failed: "" + get_libdwarf_err()
        print('stack', varnode)
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, 'Memory address'
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, ('ERR var:', varnode)
    
    add_loc_expr = dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err)
    assert add_loc_expr is not None, ""dwarf_add_AT_location_expr failed: "" + get_libdwarf_err()
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die == None:
        stderr.write(""dwarf_new_die error"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        stderr.write(""dwarf_add_expr_gen error"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) == None:
        stderr.write(""dwarf_add_AT_location_expr error"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) == None:
        stderr.write(""dwarf_add_AT_string error"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name in ('main', 'dup_example', 'entry'):
        print('-- %s:' % f_name)
        add_decompiler_func_info(cu, die, func, 0)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            raise Exception((""ERR type:"", type(t), t))
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) == None:
        stderr.write(""dwarf_add_AT_reference child error"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) == None:
        stderr.write(""dwarf_add_AT_unsigned_const error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) == None:
        stderr.write(""dwarf_add_AT_name error"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            stderr.write(""dward_add_expr_gen error"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) == None:
            stderr.write(""dwarf_add_AT_location_expr error"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,baa20682d58250c00408810a594cc6f371675610,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/baa20682d58250c00408810a594cc6f371675610
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()['DW_OP_breg%d' % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, source_file_dwarfindex):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err);
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, 'Memory address'
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, ('ERR var:', varnode)
    
    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)
    if f_name in ('main', 'dup_example', 'entry'):
        # print('-- %s:' % f_name)
        add_decompiler_func_info(cu, die, func, 0)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,45b95669f12f303010495eea98193fec9f70a1de,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/45b95669f12f303010495eea98193fec9f70a1de
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())

    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()['DW_OP_breg%d' % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err);
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, 'Memory address'
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, ('ERR var:', varnode)
    
    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/f4c9f6e827faf4d8c7aa6a6d9c8ec45acd9c40f4
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())

    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()['DW_OP_breg%d' % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr: # TODO: is this ok?
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err);
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, 'Memory address'
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, ('ERR var:', varnode)
    
    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print('section_count', section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip('.'))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, 'wb') as f:
            f.write(content)
            print('written', file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print('info_callback', name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0690bf9460643038e4e67e0dc66dcd33aa38ca2c,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/0690bf9460643038e4e67e0dc66dcd33aa38ca2c
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    print(cu)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, ext_dbg(curr.name), err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, ext_dbg(curr.name), err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()['DW_OP_breg%d' % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr: # TODO: is this ok?
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err);
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, 'Memory address'
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, ('ERR var:', varnode)
    
    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print('section_count', section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip('.'))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, 'wb') as f:
            f.write(content)
            print('written', file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print('info_callback', name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,0456af979005cb5baed32718eda06f35691b1ec6,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/0456af979005cb5baed32718eda06f35691b1ec6
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__init__,"    def __init__(self, name='', code=0, closure=None):
        """"""
        Create a coding instance.
        """"""

        self._name = name
        self._code = code
        self._closure = closure

        # only the last entry counts
        if ((not self.overload_names) and name in self.byname
            or ((not self.overload_codes) and code in self.bycode)):
            raise KeyError

        self.byname[name] = self
        self.bycode[code] = self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,name,"    def name(self):
        """"""name accessor""""""
        return self._name",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,name,"    def name(self, value):
        """"""name setter""""""
        raise NotImplementedError",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,code,"    def code(self):
        """"""code accessor""""""
        return self._code",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,code,"    def code(self, value):
        """"""code setter""""""
        raise NotImplementedError",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,closure,"    def closure(self):
        """"""closure accessor""""""
        return self._closure",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,closure,"    def closure(self, value):
        """"""closure setter""""""
        raise NotImplementedError",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__index__,"    def __index__(self):
        return self.code",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__hash__,"    def __hash__(self):
        return self.code",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__int__,"    def __int__(self):
        return self.code",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__call__,"    def __call__(self):
        return self.closure",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__repr__,"    def __repr__(self):
        return '{0}(name={1}, code={2}, closure={3})'.format(
            self.__class__.__name__, self.name, self.code, self.closure)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__str__,"    def __str__(self):
        return self.name",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__lt__,"    def __lt__(self, other):
        return (self.name < other.name
                or ((self.name == other.name)
                    and (self.code < other.code)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__le__,"    def __le__(self, other):
        return (self.name <= other.name
                or ((self.name == other.name)
                    and (self.code <= other.code)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__eq__,"    def __eq__(self, other):
        return (self.name == other.name
                and self.code == other.code)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__ne__,"    def __ne__(self, other):
        return (self.name != other.name
                and self.code != other.code)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__gt__,"    def __gt__(self, other):
        return (self.name > other.name
                or ((self.name == other.name)
                    and (self.code > other.code)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__ge__,"    def __ge__(self, other):
        return (self.name >= other.name
                or ((self.name == other.name)
                    and (self.code >= other.code)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__lt__,"    def __lt__(self, other):
        return (self.code < other.code
                or ((self.code == other.code)
                    and (self.name < other.name)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__le__,"    def __le__(self, other):
        return (self.code <= other.code
                or ((self.code == other.code)
                    and (self.name <= other.name)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__eq__,"    def __eq__(self, other):
        return (self.code == other.code
                and self.name == other.name)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__ne__,"    def __ne__(self, other):
        return (self.code != other.code
                and self.name != other.name)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__gt__,"    def __gt__(self, other):
        return (self.code > other.code
                or ((self.code == other.code)
                    and (self.name > other.name)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,coding.py,__ge__,"    def __ge__(self, other):
        return (self.code >= other.code
                or ((self.code == other.code)
                    and (self.name >= other.name)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,open,"def open(name=None, fileobj=None, map=None, block=None):
    """"""

    The open function takes some form of file identifier and creates
    an :py:class:`ElfFile` instance from it.

    :param :py:class:`str` name: a file name
    :param :py:class:`file` fileobj: if given, this overrides *name*
    :param :py:class:`mmap.mmap` map: if given, this overrides *fileobj*
    :param :py:class:`bytes` block: file contents in a block of memory, (if given, this overrides *map*)

    The file to be used can be specified in any of four different
    forms, (in reverse precedence):

    #. a file name
    #. :py:class:`file` object
    #. :py:mod:`mmap.mmap`, or
    #. a block of memory
    """"""

    if block:
        if not name:
            name = '<unknown>'

        efi = ElfFileIdent()
        efi.unpack_from(block)

        ef = ElfFile.encodedClass(efi)(name, efi)
        ef.unpack_from(block)

        if fileobj:
            fileobj.close()

        return ef

    if map:
        block = map

    elif fileobj:
        map = mmap.mmap(fileobj.fileno(), 0, access=mmap.ACCESS_READ)

    elif name:
        fileobj = io.open(os.path.normpath(os.path.expanduser(name)), 'rb')

    else:
        assert False
        
    return open(name=name,
                fileobj=fileobj,
                map=map,
                block=block)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack,"    def unpack(self, block):
        return self.unpack_from(block)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack_from,"    def unpack_from(self, block, offset=0):
        """"""
        Set the values of this instance from an in-memory
        representation of the struct.

        :param string block: block of memory from which to unpack
        :param int offset: optional offset into the memory block from
            which to start unpacking
        """"""
        raise NotImplementedError",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack,"    def pack(self):
        x = bytearray(self.size)
        self.pack_into(x)
        return x",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack_into,"    def pack_into(self, block, offset=0):
        """"""
        Store the values of this instance into an in-memory
        representation of the file.

        :param string block: block of memory into which to pack
        :param int offset: optional offset into the memory block into
            which to start packing
        """"""
        raise NotImplementedError",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__eq__,"    def __eq__(self, other):
        raise NotImplementedError",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__ne__,"    def __ne__(self, other):
        return not self.__eq__(other)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,close_enough,"    def close_enough(self, other):
        """"""
        This is a comparison similar to __eq__ except that here the
        goal is to determine whether two objects are ""close enough""
        despite perhaps having been produced at different times in
        different locations in the file system.
        """"""
        return self == other",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack_from,"    def unpack_from(self, block, offset=0):
        (self.magic, self.elfClass, self.elfData, self.fileVersion, self.osabi,
         self.abiversion) = self.coder.unpack_from(block, offset)
        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack_into,"    def pack_into(self, block, offset=0):
        bb = self.coder.pack( self.magic, self.elfClass,
                             self.elfData, self.fileVersion,
                             self.osabi, self.abiversion)
        block[offset:offset + len(bb)] = bb

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__repr__,"    def __repr__(self):
        return ('<{0}@{1}: coder={2}, magic=\'{3}\', elfClass={4}, elfData={5}, fileVersion={6}, osabi={7}, abiversion={8}>'
                .format(self.__class__.__name__, hex(id(self)), self.coder, self.magic,
                        ElfClass.bycode[self.elfClass] if self.elfClass in ElfClass.bycode else self.elfClass,
                        ElfData.bycode[self.elfData] if self.elfData in ElfData.bycode else self.elfData,
                        self.fileVersion, self.osabi, self.abiversion))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__eq__,"    def __eq__(self, other):
        return (isinstance(other, self.__class__)
                and self.coder == other.coder
                and self.magic == other.magic
                and self.elfClass == other.elfClass
                and self.elfData == other.elfData
                and self.fileVersion == other.fileVersion
                and self.osabi == other.osabi
                and self.abiversion == other.abiversion)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_list_encode,"    def _list_encode(self):
        return (self.__class__.__name__,
                hex(id(self)),
                {
                    'coder': self.coder,
                    'magic': self.magic,
                    'elfClass': ElfClass.bycode[self.elfClass].name,
                    'elfData': ElfData.bycode[self.elfData].name,
                    'fileVersion': self.fileVersion,
                    'osabi': self.osabi,
                    'abiversion': self.abiversion,
                })",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,encodedClass,"    def encodedClass(ident):
        """"""
        :param :py:class:`ElfFileIdent`:  This is
        :rtype :py:class:`ElfFile`: broken
        .. todo:: file sphinx bug on this once code is released so that they can see it.

        Given an *ident*, return a suitable :py:class:`ElfFile` subclass to represent that file.

        Raises :py:exc:`NO_CLASS` if the :py:class:`ElfClass`, (word size), cannot be represented.

        Raises :py:exc:`NO_ENCODING` if the :py:class:`ElfData`, (byte order), cannot be represented.
        """"""
        classcode = ident.elfClass
        if classcode in _fileEncodingDict:
            elfclass = _fileEncodingDict[classcode]
        else:
            raise ElfFile.NO_CLASS

        endiancode = ident.elfData
        if endiancode in elfclass:
            return elfclass[endiancode]
        else:
            raise ElfFile.NO_ENCODING",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__new__,"    def __new__(cls, name, fileIdent):
        assert fileIdent

        if cls != ElfFile:
            return object.__new__(cls)

        retval = ElfFile.__new__(ElfFile.encodedClass(fileIdent), name, fileIdent)
        retval.__init__(name, fileIdent)
        return retval",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__init__,"    def __init__(self, name, fileIdent):
        """"""
        :param :py:class:`str` name
        :param :py:class:`ElfFileIdent`
        """"""

        self.name = name

        self.fileIdent = fileIdent
        self.fileHeader = None
        self.sectionHeaders = []
        self.programHeaders = []",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack_from,"    def unpack_from(self, block, offset=0):
        """"""
        Unpack an entire file.

        .. todo:: I don't understand whether segments overlap sections
            or not.
        """"""

        self._unpack_fileIdent(block, offset)
        self._unpack_file_header(block, offset)
        self._unpack_section_headers(block, offset)
        self._unpack_sections(block, offset)
        self._unpack_section_names()
        self._unpack_program_headers(block, offset)
        self._unpack_segments(block, offset)

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_unpack_fileIdent,"    def _unpack_fileIdent(self, block, offset):
        if not self.fileIdent:
            self.fileIdent = ElfFileIdent()

        self.fileIdent.unpack_from(block, offset)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_unpack_file_header,"    def _unpack_file_header(self, block, offset):
        if not self.fileHeader:
            self.fileHeader = self.fileHeaderClass()

        self.fileHeader.unpack_from(block, offset + self.fileIdent.size)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_unpack_section_headers,"    def _unpack_section_headers(self, block, offset):
        # section headers
        if self.fileHeader.shoff != 0:
            sectionCount = self.fileHeader.shnum

            self.sectionHeaders.append(self.sectionHeaderClass().unpack_from(block, offset + self.fileHeader.shoff))

            if sectionCount == 0:
                sectionCount = self.sectionHeaders[0].section_size
                
            for i in range(1, sectionCount):
                self.sectionHeaders.append(self.sectionHeaderClass().unpack_from(block,
                                                                            offset + self.fileHeader.shoff
                                                                            + (i * self.fileHeader.shentsize)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_unpack_sections,"    def _unpack_sections(self, block, offset):
        for sh in self.sectionHeaders:
            sh.content = block[offset + sh.offset:offset + sh.offset + sh.section_size] # section contents are copied",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_unpack_section_names,"    def _unpack_section_names(self):
        # little tricky here - can't read section names until after
        # that section has been read.  So effectively this is two pass.

        for section in self.sectionHeaders:
            section.name = self.sectionName(section)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_unpack_program_headers,"    def _unpack_program_headers(self, block, offset):
        if self.fileHeader.phoff != 0:
            segmentCount = self.fileHeader.phnum

            self.programHeaders.append(self.programHeaderClass().unpack_from(block, offset + self.fileHeader.phoff))

            if segmentCount == ElfProgramHeader.PN_XNUM:
                segmentCount = self.sectionHeaders[0].info

            for i in range(1, segmentCount):
                self.programHeaders.append(self.programHeaderClass().unpack_from(block,
                                                                                 offset + self.fileHeader.phoff
                                                                                 + (i * self.fileHeader.phentsize)))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_unpack_segments,"    def _unpack_segments(self, block, offset):
        for ph in self.programHeaders:
            ph.content = block[offset + ph.offset:offset + ph.offset + ph.filesz] # segment contents are copied",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack_into,"    def pack_into(self, block, offset=0):
        """"""
        Pack the entire file.  Rewrite offsets as necessary.
        """"""

        self._regen_section_name_table()
        self._regen_program_header_table()

        total, scoff, shoff, pcoff, phoff = self._offsets(offset)

        self._pack_file_header(block, offset, shoff, phoff)
        self._pack_sections(block, scoff)
        self._pack_section_headers(block, shoff)
        self._pack_segments(block, pcoff)
        self._fix_program_header_table(phoff, total - phoff)
        self._pack_program_headers(block, phoff)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_find_segment_for_section,"    def _find_segment_for_section(self, sh):
        segments = [ph for ph in self.programHeaders 
            if sh.offset >= ph.offset 
            and sh.offset + sh.section_size <= ph.offset + ph.filesz]
        return max(segments, key=lambda ph: ph.offset) if segments else None",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_offsets,"    def _offsets(self, offset=0, alignment=16):
        """"""
        Current packing layout is:

        * fileIdent + fileHeader
        * section contents
        * sectionHeaders
        """"""
        def get_align(x):
            return (alignment - x % alignment) % alignment

        x = offset

        x += self.fileHeader.ehsize
        scoff = x

        x += sum(sh.section_size for sh in self.sectionHeaders)
        x += get_align(x)
        shoff = x

        x += len(self.sectionHeaders) * self.fileHeader.shentsize
        x += get_align(x)
        pcoff = x

        x += sum(ph.filesz for ph in self.programHeaders)
        x += get_align(x)
        phoff = x

        x += (len(self.programHeaders) * self.fileHeader.phentsize)
        x += get_align(x)
        total = x

        return total, scoff, shoff, pcoff, phoff",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_regen_section_name_table,"    def _regen_section_name_table(self):
        """"""
        (Re)build the section name table section.
        """"""

        # rewrite existing section.  If none exists, we're in trouble.
        # (Will need to deal with that case when it arises.)
        assert self.fileHeader.shstrndx

        section = self.sectionHeaders[self.fileHeader.shstrndx]

        # sum of the sizes of all of the names plus initial null plus
        # all terminating nulls

        # FIXME: could merge pointers to same strings and/or common suffixes.

        section.section_size = sum(len(sh.name) + 1 for sh in self.sectionHeaders)

        section.content = bytearray(section.section_size)

        p = 0
        #section.content[p] = b'\0'
        #p += 1

        for sh in self.sectionHeaders:
            ph = self._find_segment_for_section(sh)
            l = len(sh.name)
            print(sh.name, p, l)
            if ph:
                print('FIND', '%5d %5d %5d %5d' % (ph.offset, sh.offset, sh.offset + sh.section_size, ph.offset + ph.filesz), ph)
            else:
                print('FIND NOPE', '%d %d' % (sh.offset, sh.offset + sh.section_size))
            section.content[p:p+l] = sh.name
            sh.nameoffset = p
            p += l
            section.content[p] = b'\0'
            p += 1

        print(section.section_size, section.content)
        print(self.fileHeader.shstrndx, self.sectionHeaders[self.fileHeader.shstrndx])",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_regen_program_header_table,"    def _regen_program_header_table(self):
        for ph in self.programHeaders:
            if PT.bycode[ph.type] == PT.byname['PT_PHDR']:
                ph.content = ''",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_fix_program_header_table,"    def _fix_program_header_table(self, phoff, phsize):
        for ph in self.programHeaders:
            if PT.bycode[ph.type] == PT.byname['PT_PHDR']:
                ph.offset = phoff
                ph.filesz = ph.memsz = phsize",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_pack_file_header,"    def _pack_file_header(self, block, offset, shoff, phoff):
        """"""
        Determine and set current offsets then pack the file header.
        """"""
        self.fileIdent.pack_into(block, offset)

        self.fileHeader.shoff = shoff if len(self.sectionHeaders) > 0 else 0
        self.fileHeader.phoff = phoff if len(self.programHeaders) > 0 else 0
        self.fileHeader.pack_into(block, offset + self.fileIdent.size)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_pack_sections,"    def _pack_sections(self, block, offset=0):
        """"""
        Pack the section contents.  As a side effect, set the offsets
        in the section headers telling where we put them and the
        section_sizes telling how much we put.
        """"""
        p = offset
        for section in self.sectionHeaders:
            section.offset = p
            section.section_size = len(section.content)
            block[p:p + section.section_size] = section.content
            p += section.section_size",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_pack_section_headers,"    def _pack_section_headers(self, block, offset):
        """"""
        Pack the section header table.

        .. todo:: first section header is reserved and should be all
            zeros.  Need to verify this and/or force one.
        """"""
        for i, sh in enumerate(self.sectionHeaders):
            print('packing sh', i, self.sectionName(sh))
            sh.pack_into(block, offset + (i * self.fileHeader.shentsize))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_pack_segments,"    def _pack_segments(self, block, offset):
        p = offset
        for ph in self.programHeaders:
            ph.offset = p
            sz = len(ph.content)
            ph.filesz = ph.memsz = sz
            block[p:p + sz] = ph.content
            p += sz",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_pack_program_headers,"    def _pack_program_headers(self, block, offset):
        for i, ph in enumerate(self.programHeaders):
            print('packing ph', i, PT.bycode[ph.type])
            ph.pack_into(block, offset + (i * self.fileHeader.phentsize))            ",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,size,"    def size(self):
        return self._offsets()[0]",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,sectionName,"    def sectionName(self, section):
        """"""
        Given a section, return it's name.

        :param :py:class:`ElfSectionHeader` section:
        """"""
        x = self.sectionHeaders[self.fileHeader.shstrndx].content
        return x[section.nameoffset:x.find(b'\0', section.nameoffset)]",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__eq__,"    def __eq__(self, other):
        """"""
        .. todo:: it would not be difficult to break up the string
            table, sort, and compare the results.  But then we'll also
            need a way to stub out the embedded path names.
        """"""

        if not isinstance(other, self.__class__):
            return False

        if (self.fileIdent != other.fileIdent
            or self.fileHeader != other.fileHeader):
            return False

        # FIXME: need to handle order independence
        for this, that in zip(self.sectionHeaders, other.sectionHeaders):
            if this != that:
                import sys
                print('{0} differs from {1}'.format(this, that), file=sys.stderr)
                return False

        return True",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,close_enough,"    def close_enough(self, other):
        """"""
        .. todo:: it would not be difficult to break up the string
            table, sort, and compare the results.  But then we'll also
            need a way to stub out the embedded path names.
        """"""

        if not isinstance(other, self.__class__):
            return False

        if ((not self.fileIdent.close_enough(other.fileIdent))
            or (not self.fileHeader.close_enough(other.fileHeader))):
            return False

        # FIXME: need to handle order independence
        for this, that in zip(self.sectionHeaders, other.sectionHeaders):
            if (this.name in [
                '.ARM.attributes',
                '.ARM.exidx',
                '.ARM.extab',
                '.comment',
                '.debug_aranges',
                '.debug_frame',
                '.debug_info',    # x86_64 linux dyn
                '.debug_line',    # arm debug lines contain file names
                '.debug_loc',
                '.debug_pubnames',
                '.debug_ranges',
                '.debug_str',           # x86_64 linux rela
                '.gnu_debuglink',       # arm: maybe time stamps?
                '.note.GNU-stack',
                '.note.gnu.build-id',   # x86_64 linux dyn
                '.rel.ARM.exidx',
                '.rel.debug_aranges',
                '.rel.debug_frame',
                '.rel.debug_info',      # x86_64 linux rela
                '.rel.debug_line',
                '.rel.debug_pubnames',
                '.rel.text',
                '.rodata',
                '.rodata.str1.4',
                '.shstrtab',
                '.strtab',
                '.symtab',
                ]
                or this.type == SHT.byname['SHT_NOBITS'].code # Not sure what this is or why it differs
                ):
                continue

            if not this.close_enough(that):
                import sys
                print('section({0}) not close enough to section({1})'.format(this.name, that.name), file=sys.stdout)
                return False

        return True",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__repr__,"    def __repr__(self):
        return ('<{0}@{1}: name=\'{2}\', fileIdent={3}, fileHeader={4}>'
                .format(self.__class__.__name__, hex(id(self)), self.name, self.fileIdent, self.fileHeader))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_list_encode,"    def _list_encode(self):
        return (self.__class__.__name__,
                hex(id(self)),
                {
                    'name': self.name,
                    'fileIdent': self.fileIdent._list_encode(),
                    'fileHeader': self.fileHeader._list_encode(),
                    'sectionHeaders': [sh._list_encode() for sh in self.sectionHeaders],
                    'programHeaders': [ph._list_encode() for ph in self.programHeaders],
                })",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack_from,"    def unpack_from(self, block, offset=0):
        (self.type, self.machine, self.version, self.entry,
         self.phoff, self.shoff, self.flags, self.ehsize,
         self.phentsize, self.phnum, self.shentsize, self.shnum,
         self.shstrndx) = self.coder.unpack_from(block, offset)

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack_into,"    def pack_into(self, block, offset=0):
        assert(self.type in ET.bycode)
        assert(self.machine in EM.bycode)

        bb = self.coder.pack( self.type, self.machine,
                             self.version if self.version != None else 1,
                             self.entry if self.entry != None else 0,
                             self.phoff if self.phoff != None else 0,
                             self.shoff if self.shoff != None else 0,
                             self.flags if self.flags != None else 0,
                             self.ehsize if self.ehsize != None else self.size,
                             self.phentsize if self.phentsize != None else self.programHeaderClass.size,
                             self.phnum if self.phnum != None else 0,
                             self.shentsize if self.shentsize != None else self.sectionHeaderClass.size,
                             self.shnum if self.shnum != None else 0,
                             self.shstrndx if self.shstrndx != None else 0)
        block[offset:offset + len(bb)] = bb

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__eq__,"    def __eq__(self, other):
        return (isinstance(other, self.__class__)
                and self.type == other.type
                and self.machine == other.machine
                and self.version == other.version
                and self.entry == other.entry
                and self.phoff == other.phoff
                # and self.shoff == other.shoff
                and self.flags == other.flags
                and self.ehsize == other.ehsize
                and self.phentsize == other.phentsize
                and self.phnum == other.phnum
                and self.shentsize == other.shentsize
                and self.shnum == other.shnum
                and self.shstrndx == other.shstrndx)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,close_enough,"    def close_enough(self, other):
        return (isinstance(other, self.__class__)
                and self.type == other.type
                and self.machine == other.machine
                and self.version == other.version
                and self.entry == other.entry
                and self.phoff == other.phoff
                and self.flags == other.flags
                and self.ehsize == other.ehsize
                and self.phentsize == other.phentsize
                and self.phnum == other.phnum
                and self.shentsize == other.shentsize
                and self.shnum == other.shnum
                and self.shstrndx == other.shstrndx)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__repr__,"    def __repr__(self):
        return ('<{0}@{1}: type={2}, machine={3}, version={4},'
                ' entry={5}, phoff={6}, shoff={7}, flags={8},'
                ' ehsize={9}, phnum={10}, shentsize={11}, shnum={12},'
                ' shstrndx={13}>'
                .format(self.__class__.__name__, hex(id(self)), ET.bycode[self.type], EM.bycode[self.machine],
                        self.version, hex(self.entry), self.phoff, self.shoff,
                        hex(self.flags), self.ehsize, self.phnum, self.shentsize,
                        self.shnum, self.shstrndx))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_list_encode,"    def _list_encode(self):
        return (self.__class__.__name__,
                hex(id(self)),
                {
                    'type': ET.bycode[self.type].name,
                    'machine': EM.bycode[self.machine].name,
                    'version': self.version,
                    'entry': hex(self.entry),
                    'phoff': self.phoff,
                    'shoff': self.shoff,
                    'flags': hex(self.flags),
                    'ehsize': self.ehsize,
                    'phnum': self.phnum,
                    'shentsize': self.shentsize,
                    'shnum': self.shnum,
                    'shstrndx': self.shstrndx,
                })",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack_from,"    def unpack_from(self, block, offset=0):
        (self.nameoffset, self.type, self.flags, self.addr,
         self.offset, self.section_size, self.link, self.info,
         self.addralign, self.entsize) = self.coder.unpack_from(block, offset)

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack_into,"    def pack_into(self, block, offset=0):
        """"""
        .. note:: this is a special case.  *block* here must be the
            entire file or we won't know how to place our content.
        """"""
        bb = self.coder.pack(
                             self.nameoffset, self.type, self.flags, self.addr,
                             self.offset, self.section_size, self.link, self.info,
                             self.addralign, self.entsize)
        block[offset:offset + len(bb)] = bb

        block[self.offset:self.offset + self.section_size] = self.content

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__eq__,"    def __eq__(self, other):
        return (isinstance(other, self.__class__)
                and self.nameoffset == other.nameoffset
                and self.type == other.type
                and self.flags == other.flags
                and self.addr == other.addr
                and self.offset == other.offset
                and self.section_size == other.section_size
                and self.link == other.link
                and self.info == other.info
                and self.addralign == other.addralign
                and self.entsize == other.entsize
                and self.content == other.content)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,close_enough,"    def close_enough(self, other):
        return (isinstance(other, self.__class__)
                and self.nameoffset == other.nameoffset
                and self.type == other.type
                and self.flags == other.flags
                and self.addr == other.addr
                and self.section_size == other.section_size
                and self.link == other.link
                and self.info == other.info
                and self.addralign == other.addralign
                and self.entsize == other.entsize
                and self.content == other.content)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__repr__,"    def __repr__(self):
        # FIXME: I wish I could include the first few bytes of the content as well.
        return ('<{0}@{1}: name=\'{2}\', type={3},'
                ' flags={4}, addr={5}, offset={6}, section_size={7},'
                ' link={8}, info={9}, addralign={10}, entsize={11}>'
                .format(self.__class__.__name__, hex(id(self)), self.name,
                        SHT.bycode[self.type] if self.type in SHT.bycode else hex(self.type),
                        hex(self.flags), hex(self.addr), self.offset, self.section_size,
                        self.link, self.info, self.addralign, self.entsize))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_list_encode,"    def _list_encode(self):
        return (self.__class__.__name__,
                hex(id(self)),
                {
                    'name': self.name,
                    'type': SHT.bycode[self.type].name if self.type in SHT.bycode else self.type,
                    'flags': hex(self.flags),
                    'offset': self.offset,
                    'section_size': self.section_size,
                    'link': self.link,
                    'info': self.info,
                    'addralign': self.addralign,
                    'entsize': self.entsize,
                })",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__eq__,"    def __eq__(self, other):
        return (isinstance(other, self.__class__)
                and self.type == other.type
                and self.offset == other.offset
                and self.vaddr == other.vaddr
                and self.paddr == other.paddr
                and self.filesz == other.filesz
                and self.memsz == other.memsz
                and self.flags == other.flags
                and self.align == other.align)",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__repr__,"    def __repr__(self):
        return ('<{0}@{1}: type={2},'
                ' offset={3}, vaddr={4}, paddr={5},'
                ' filesz={6}, memsz={7}, flags={8}, align={9}>'
                .format(self.__class__.__name__, hex(id(self)),
                        PT.bycode[self.type].name if self.type in PT.bycode else self.type,
                        self.offset, hex(self.vaddr), hex(self.paddr),
                        self.filesz, self.memsz, hex(self.flags), self.align))",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,_list_encode,"    def _list_encode(self):
        return (self.__class__.__name__,
                hex(id(self)),
                {
                    'type': PT.bycode[self.type].name if self.type in PT.bycode else self.type,
                    'offset': self.offset,
                    'vaddr': hex(self.vaddr),
                    'paddr': hex(self.paddr),
                    'filesz': self.filesz,
                    'memsz': self.memsz,
                    'flags': hex(self.flags),
                    'align': self.align,
                })",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack_from,"    def unpack_from(self, block, offset=0):
        (self.type, self.offset, self.vaddr, self.paddr,
         self.filesz, self.memsz, self.flags, self.align) = self.coder.unpack_from(block, offset)

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack_into,"    def pack_into(self, block, offset=0):
        bb = self.coder.pack(
                             self.type, self.offset, self.vaddr, self.paddr,
                             self.filesz, self.memsz, self.flags, self.align)
        block[offset:offset + len(bb)] = bb

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,unpack_from,"    def unpack_from(self, block, offset=0):
        (self.type, self.flags, self.offset, self.vaddr,
         self.paddr, self.filesz, self.memsz, self.align) = self.coder.unpack_from(block, offset)

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,pack_into,"    def pack_into(self, block, offset=0):
        bb = self.coder.pack(
                             self.type, self.flags, self.offset, self.vaddr,
                             self.paddr, self.filesz, self.memsz, self.align)
        block[offset:offset + len(bb)] = bb

        return self",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,__get__,"        def __get__(self, obj, t):
            return t.coder.size",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,e5aef1c308335c3887b5ba93957db9c0a80e4b43,elffile.py,get_align,"        def get_align(x):
            return (alignment - x % alignment) % alignment",https://www.github.com/cesena/ghidra2dwarf/commit/e5aef1c308335c3887b5ba93957db9c0a80e4b43
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()['DW_OP_breg%d' % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr: # TODO: is this ok?
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err);
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, 'Memory address'
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, ('ERR var:', varnode)
    
    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index)
        # add_decompiler_func_info(cu, die, func, file, linecount, file_index, 0)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print('section_count', section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip('.'))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, 'wb') as f:
            f.write(content)
            print('written', file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print('info_callback', name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,deed98a52c7a78a8266c471637c7954d6c8386d1,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/deed98a52c7a78a8266c471637c7954d6c8386d1
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()['DW_OP_breg%d' % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr: # TODO: is this ok?
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err);
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, 'Memory address'
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, ('ERR var:', varnode)
    
    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    # ret_type_die = add_type(cu, func.returnType)
    # dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # In test.exe.dbg generated by dwarfexport there isn't file_index and linecount
        # Don't decompile for now
        # dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        # dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        # dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file_index)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_type,"def add_type(cu, t):
    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    if dwarf_add_AT_name(die, struct.name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print('section_count', section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip('.'))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, 'wb') as f:
            f.write(content)
            print('written', file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print('info_callback', name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,9776325675fdfc7faf1984a2f98d8d3ad2822aab,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/9776325675fdfc7faf1984a2f98d8d3ad2822aab
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:  # TODO: is this ok?
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, ""Memory address""
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, (""ERR var:"", varnode)

    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # In test.exe.dbg generated by dwarfexport there isn't file_index and linecount
        # Don't decompile for now
        # dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        # dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        # dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file_index)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    # add_type(cu, func.returnType.description)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_compile_unit, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    for k, v in record.items():
        print(k, v)

    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip("".""))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/a4b26dcbbf10b2e82adb7103d827de7c23f8dbfa
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    linecount = 1
    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, linecount, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:  # TODO: is this ok?
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, ""Memory address""
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, (""ERR var:"", varnode)

    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_function,"def add_function(cu, func, linecount, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: Update with current file_index and linecount
        # dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        # dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        # dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file_index)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    for k, v in record.items():
        print(k, v)

    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip("".""))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,a1a9a693684e4ef546fe2cd0fe088b776668fe0b,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/a1a9a693684e4ef546fe2cd0fe088b776668fe0b
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:  # TODO: is this ok?
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, ""Memory address""
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, (""ERR var:"", varnode)

    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, use CCodeMarkup?
        linecount = sum(1 for line in open(ext_c(curr.name))) + 6
        with open(ext_c(curr.name), ""a"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        # TODO: Update with current file_index and linecount
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        # add_decompiler_func_info(cu, die, func, file_index)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    """"""
    for k, v in record.items():
        print(k, v)
    """"""
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip("".""))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,e1f250914e603b36df57cc559d913b008b6dfe56,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/e1f250914e603b36df57cc559d913b008b6dfe56
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber + linecount, 0, True, False, err)",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    if varnode_addr.isRegisterAddress():
        reg = curr.getRegister(varnode_addr, varnode.size)
        reg_dwarf = register_mappings[reg.offset]
        if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isStackAddress():
        if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dwarf_add_expr_gen"")
    elif varnode_addr.isMemoryAddress():
        # TODO: globals?
        assert False, ""Memory address""
    elif varnode_addr.isHashAddress():
        # TODO: ghidra synthetic vars.
        # It however often can be linked to a register(/stack off?) if looking at the disass,
        # find, if possible, how to get it programmatically.
        # This info is likely lost when generating the decompiled code. :(
        # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
        pass
    else:
        assert False, (""ERR var:"", varnode)

    if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name))) + 7
        with open(ext_c(curr.name), ""a"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        # TODO: Update with current file_index and linecount
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    """"""
    for k, v in record.items():
        print(k, v)
    """"""
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip("".""))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,c66151ec3fd37eec8e6e4b6055794ca82bb90c25,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/c66151ec3fd37eec8e6e4b6055794ca82bb90c25
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err
            )",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name))) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""a"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        # TODO: Update with current file_index and linecount
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    """"""
    for k, v in record.items():
        print(k, v)
    """"""
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip("".""))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,1784be3e0e2970697cc120eddacb9fa3beb3ee51,dwarfexport.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/1784be3e0e2970697cc120eddacb9fa3beb3ee51
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err
            )",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name))) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""a"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        # TODO: Update with current file_index and linecount
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    """"""
    for k, v in record.items():
        print(k, v)
    """"""
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip("".""))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,bba66823feaab23bd713c21400ff20f63320cfa0,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/bba66823feaab23bd713c21400ff20f63320cfa0
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, ext_c(curr.name), err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, ext_c(curr.name), dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)
    # memory = curr.getMemory()
    # Get sections
    # memory.getBlocks()

    # Get segments
    # memory.getLoadedAndInitializedAddressSet()

    # Get executable segments
    # list(memory.getExecuteSet().getAddressRanges())

    # However we can omit this step and directly decompile all functions

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err
            )",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    # TODO: Understand difference between c_name and mangled_name
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    # print(f_start, f_end, type(t), t.description, func.name)
    # TODO: Fix add_type function
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name))) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""a"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        # TODO: Update with current file_index and linecount
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name.lstrip("".""))

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith('java'):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/720c8c1b792eedcab0b234d8e9ee8a51e4f59a0f
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err
            )",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name))) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""a"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith('java'):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,2d7c5f7eeaa176598495aa48014a6db2b87f9607,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/2d7c5f7eeaa176598495aa48014a6db2b87f9607
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err
            )",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.dataType.name, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith('java'):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/ae3b4ada742a5da4246ce6ebbad6fb3f8c7d50d4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err
            )",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            if dwarf_add_expr_gen(expr, stack_register_dwarf, varnode_addr.offset, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,ec747c293e438cd51c3f03c0a95f31c3ccf1dff4,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/ec747c293e438cd51c3f03c0a95f31c3ccf1dff4
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err
            )",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,0a8e3d40fe5e041552c5d7a7bc65c3db81b27303,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/0a8e3d40fe5e041552c5d7a7bc65c3db81b27303
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,is_pie,"def is_pie(curr):
    with open(curr.executablePath, ""rb"") as f:
        f.seek(0x10)
        return f.read(1) == ""\x03""",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,4a95f7022dae62812f98b0d8246c1268cbc61e54,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/4a95f7022dae62812f98b0d8246c1268cbc61e54
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,is_pie,"def is_pie(curr):
    offset = 0x10 + curr.imageBase.offset
    return curr.memory.getByte(curr.addressFactory.defaultAddressSpace.getAddress(offset)) == 3",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,6d5ab3e70e8f6b9e887d8df03208553815e09a8a,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/6d5ab3e70e8f6b9e887d8df03208553815e09a8a
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,1cad26284fef8611d5785235a7ce24d8b6844a14,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/1cad26284fef8611d5785235a7ce24d8b6844a14
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, DefaultDataType):
        # TODO: an example of DefaultDataType is `undefined`, The following line is not definitive
        return add_default_type(cu, t)
    elif isinstance(t, BuiltInDataType):
        return add_default_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,0454f8b6982cb30d76aa3463d5d7a679c09bb30a,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/0454f8b6982cb30d76aa3463d5d7a679c09bb30a
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    varnode_addr = varnode.getAddress()

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,4f61106ab6120a30b40a4b7464e5f4c60f278bc2,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/4f61106ab6120a30b40a4b7464e5f4c60f278bc2
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    path, _ = os.path.split(curr.executablePath)
    path = "".""
    if options.use_decompiler:
        if dwarf_add_AT_name(cu, curr.name + "".c"", err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, path, err)
        file_index = dwarf_add_file_decl(dbg, curr.name + "".c"", dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, path, err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(ext_c(curr.name), ""rb"")) + MAGIC_OFFSET
        with open(ext_c(curr.name), ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,write_detached_dwarf_file,"def write_detached_dwarf_file(path):
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")

    print(""section_count"", section_count)
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = content.getByteArray(0, length)
        section_name = debug_sections[section_index]
        print(section_index, section_name, length)
        file_path = os.path.join(path, section_name)

        # TODO: according to the .cpp we might get the same section_index multiple times?
        with open(file_path, ""wb"") as f:
            f.write(content)
            print(""written"", file_path)",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,get_os_version,"def get_os_version():
    ver = platform.lower()
    if ver.startswith(""java""):
        ver = java.lang.System.getProperty(""os.name"").lower()
    return ver",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = name.getString(0)
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,ext_c,"def ext_c(s):
    os_type = get_os_version()
    if os_type == ""linux"":
        return exe_path + ""/"" + s + "".c""
    elif ""win"" in os_type:
        return exe_path + ""\\"" + s + "".c""",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,61cce5aefe59b5206093a6cd9ab325cea36bc264,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/61cce5aefe59b5206093a6cd9ab325cea36bc264
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,add_sections_to_elf,"def add_sections_to_elf(from_file, to_file, sections):
	with open(from_file, 'rb') as f:
		bb = f.read()
	e = Elf(bb)
	print('Type:', e.type
)

	for name, s in sections:
		e.add_section(name, s)
	out = e.generate_updated_elf()
	for s in e.section_headers:
		print(s
)
	with open(to_file, 'wb') as f:
		f.write(out)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__init__,"	def __init__(self, file_offset, map, values, **kwargs):
		self.__dict__['map'] = map
		self.file_offset = file_offset
		for n, v in zip(map, values):
			if isinstance(n, tuple):
				n, f = n
				v = f(v)
			setattr(self, n, v)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,values,"	def values(self):
		vv = (getattr(self, n[0] if isinstance(n, tuple) else n) for n in self.map)
		return [v.code if isinstance(v, DumbEnumValue) else v for v in vv]",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__setattr__,"	def __setattr__(self, name, value):
		if not hasattr(self, 'repr_pos'):
			object.__setattr__(self, 'repr_pos', {})
		if name not in self.repr_pos:
			self.repr_pos[name] = len(self.repr_pos)
		return object.__setattr__(self, name, value)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__repr__,"	def __repr__(self):
		args = ', '.join('%s=%r' % (n, getattr(self, n)) for n, _ in sorted(self.repr_pos.items(), key=lambda x: x[1]))
		return '%s(%s)' % (self.__class__.__name__, args)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			'magic',
			('elf_class', ElfClass.__getitem__),
			('elf_data', ElfData.__getitem__),
			'file_version',
			'osabi',
			'abi_version',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			('type', ET.__getitem__),
			('machine', EM.__getitem__),
			'version',
			'entry',
			'phoff',
			'shoff',
			'flags',
			'ehsize',
			'phentsize',
			'phnum',
			'shentsize',
			'shnum',
			'shstrndx',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__init__,"	def __init__(self, values, file_offset):
		self.name = ''
		return ElfBase.__init__(self, file_offset, [
			'name_offset',
			('type', SHT.__getitem__),
			'flags',
			'addr',
			'offset',
			'section_size',
			'link',
			'info',
			'addralign',
			'entsize',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__init__,"	def __init__(self, bytes):
		self.bytes = bytearray(bytes)
		self.extract_ident()
		bits = '64' if self.ident.elf_class == ElfClass.ELFCLASS64 else '32'
		#bits = '64' if ElfClass[self.ident.elf_class] == ElfClass.ELFCLASS64 else '32'
		endianness = 'le' if self.ident.elf_data == ElfData.ELFDATA2LSB else 'be'
		#endianness = 'le' if ElfData[self.ident.elf_data] == ElfData.ELFDATA2LSB else 'be'
		self.type = bits + endianness
		self.new_sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,_get_struct,"	def _get_struct(self, cls):
		s = struct_coders[cls.__name__]
		return s[self.type] if isinstance(s, dict) else s",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,_dump_struct,"	def _dump_struct(self, cls, off):
		s = self._get_struct(cls)
		# unpack_from doesn't work with jython
		# return cls(s.unpack_from(self.bytes, off), file_offset=off)
		bb = self.bytes[off:off+s.size]
		return cls(s.unpack(str(bb)), file_offset=off)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,_export_struct,"	def _export_struct(self, val, off):
		s = self._get_struct(val.__class__)
		# unpack_into doesn't work with jython
		# s.pack_into(self.bytes, off, *val.values)
		self.bytes[off:off+s.size] = s.pack(*val.values)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,extract_ident,"	def extract_ident(self):
		if hasattr(self, 'ident'):
			return self.ident
		self.ident = self._dump_struct(ElfIdent, 0)
		self.header_off = self._get_struct(ElfIdent).size
		return self.ident",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,extract_header,"	def extract_header(self):
		if hasattr(self, 'header'):
			return self.header
		self.header = self._dump_struct(ElfHeader, self.header_off)
		return self.header",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,extract_section_headers,"	def extract_section_headers(self):
		if hasattr(self, 'section_headers'):
			return self.section_headers

		self.section_headers = []
		h = self.extract_header()
		for i in range(h.shnum):
			self.section_headers.append(self._dump_struct(ElfSectionHeader, h.shoff + i * h.shentsize))
		self.section_names = self.extract_section(self.section_headers[h.shstrndx])
		for s in self.section_headers:
			s.name = self.section_names[s.name_offset:self.section_names.find('\x00', s.name_offset)]
		return self.section_headers",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,extract_section,"	def extract_section(self, section_header):
		return self.bytes[section_header.offset:section_header.offset+section_header.section_size]",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,encode_section_header,"	def encode_section_header(self, section_header):
		return self._get_struct(ElfSectionHeader).pack(*section_header.values)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,add_section,"	def add_section(self, name, body):
		self.new_sections.append((name, body))",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,generate_updated_elf,"	def generate_updated_elf(self):
		section_headers = self.extract_section_headers()
		added_sections = False
		for name, body in self.new_sections:
			try:
				s = next(s for s in section_headers if s.name == name)
			except:
				added_sections = True
				name_off = len(self.section_names)
				self.section_names += name + '\x00'
				s = ElfSectionHeader([name_off, 1, 0, 0, -1, -1, 0, 0, 1, 0], file_offset=-1)
				s.name = name
				section_headers.append(s)
			s.offset = len(self.bytes)
			s.section_size = len(body)
			self.bytes += body

		h = self.header
		if added_sections:
			shstr = section_headers[h.shstrndx]
			shstr.section_size = len(self.section_names)
			shstr.offset = len(self.bytes)
			self.bytes += self.section_names
			h.shoff = len(self.bytes)
			h.shnum = len(section_headers)
			self.bytes += '\x00' * h.shentsize * h.shnum

		self._export_struct(h, self.header_off)
		for i, s in enumerate(section_headers):
			s.file_offset = h.shoff + i * h.shentsize
			self._export_struct(s, s.file_offset)

		return self.bytes",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__init__,"	def __init__(self, name, code, desc): self.name, self.code, self.desc = name, code, desc",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__repr__,"	def __repr__(self): return '%s(%r, %r)' % (self.name, self.code, self.desc)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__init__,"		def __init__(cls, *args):
			cls._bycode = {}
			for n in dir(cls):
				if n[0] != '_':
					v = DumbEnumValue(n, *getattr(cls, n))
					setattr(cls, n, v)
					cls._bycode[v.code] = v",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,elf.py,__getitem__,"		def __getitem__(cls, idx):
			try:
				return cls._bycode[idx]
			except KeyError:
				raise Exception('enum %s has no entry with code %d.' % (cls.__name__, idx))",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        if dwarf_add_AT_name(cu, c_file_name, err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, '.', err)
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, '.', err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(decompiled_c_path, ""rb"")) + MAGIC_OFFSET
        with open(decompiled_c_path, ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        ERROR(""dwarf_transform_to_disk_form"")
    print(""section_count"", section_count)

    sections = []
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            ERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        # TODO: according to the .cpp we might get the same section_index multiple times?
        section_name = debug_sections[section_index]
        sections.append((section_name, content))
        print(section_index, section_name, length)

    return sections",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,info_callback,"def info_callback(name, *args):
    name = str(name.getString(0))
    print(""info_callback"", name)
    debug_sections.append(name)
    return len(debug_sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,51062f754d14928ff5585bb206fa8c611062344e,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/51062f754d14928ff5585bb206fa8c611062344e
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        if dwarf_add_AT_name(cu, c_file_name, err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, '.', err)
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, '.', err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, linecount):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(
                dbg, file_index, lowest_addr.offset, l.lineNumber + linecount - MAGIC_OFFSET, 0, True, False, err,
            )",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    TODO: Why is not working correctly ?
    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        # TODO: thafuck, I tried with a global variable but it didn't work well...
        linecount = sum(1 for line in open(decompiled_c_path, ""rb"")) + MAGIC_OFFSET
        with open(decompiled_c_path, ""ab"") as src:
            res = get_decompiled_function(func)
            src.write(res.decompiledFunction.c)

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, linecount, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, linecount, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, linecount)
        pass
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        DERROR(""dwarf_transform_to_disk_form"")
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            DERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,d0765569309eca7e17de494249c8956974090c88,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/d0765569309eca7e17de494249c8956974090c88
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        if dwarf_add_AT_name(cu, c_file_name, err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, '.', err)
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, '.', err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [t.minAddress for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None
        # print(lowest_addr, l)
        # TODO: is this call to dwarf_lne_set_address needed?
        # dwarf_lne_set_address(dbg, lowest_line_addr, 0, &err)
        # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
        if lowest_addr:
            dwarf_add_line_entry(dbg, file_index, lowest_addr.offset, l.lineNumber + func_line - 1, 0, True, False, err,)",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return (func.entryPoint, func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start.offset >= s.minAddress.offset and f_end.offset <= s.maxAddress.offset:
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start.offset, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end.offset - 1, 0, err)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line, err)
        dwarf_add_line_entry(dbg, file_index, f_start.offset, func_line, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        DERROR(""dwarf_transform_to_disk_form"")
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            DERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/0d62dc5cb2c4e6451749da9cfb91e0d023dbffb9
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        if dwarf_add_AT_name(cu, c_file_name, err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, '.', err)
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, '.', err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0, err)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False, err,)",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0, err)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line, err)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, get_real_address(c), 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        DERROR(""dwarf_transform_to_disk_form"")
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            DERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,6a79d5c7ae81e3404c7d6355e1e930a8950ec658,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/6a79d5c7ae81e3404c7d6355e1e930a8950ec658
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        if dwarf_add_AT_name(cu, c_file_name, err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, '.', err)
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, '.', err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0, err)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False, err,)",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0, err)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line, err)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        DERROR(""dwarf_transform_to_disk_form"")
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            DERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,35ed40a9ce8efc3ed48991aa31a0598adf87169c,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/35ed40a9ce8efc3ed48991aa31a0598adf87169c
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        if dwarf_add_AT_name(cu, c_file_name, err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, '.', err)
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, '.', err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0, err)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False, err,)",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0, err)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line, err)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, 8, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        DERROR(""dwarf_transform_to_disk_form"")
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            DERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,0be247e7cf9988dd3ad711839a23ab2d6758c591,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/0be247e7cf9988dd3ad711839a23ab2d6758c591
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,DERROR,"def DERROR(func):
    assert False, ""%s failed: %s"" % (func, get_libdwarf_err())",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string, err)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None, err)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        if dwarf_add_AT_name(cu, c_file_name, err) is None:
            DERROR(""dwarf_add_AT_name"")
        dir_index = dwarf_add_directory_decl(dbg, '.', err)
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0, err)
        dwarf_add_AT_comp_dir(cu, '.', err)

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug(dbg, cu, err)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0, err)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False, err,)",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None, err)
    type_die = add_type(cu, datatype)

    if dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die, err) is None:
        DERROR(""dwarf_add_AT_reference"")

    if dwarf_add_AT_name(var_die, name, err) is None:
        DERROR(""dwarf_add_AT_name"")

    expr = dwarf_new_expr(dbg, err)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            if dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            if dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0, err) == DW_DLV_NOCOUNT:
                DERROR(""dwarf_add_expr_gen"")
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        if dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None, err)
    if die is None:
        DERROR(""dwarf_new_die"")
    loc_expr = dwarf_new_expr(dbg, err)
    if dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0, err) == DW_DLV_NOCOUNT:
        DERROR(""dwarf_add_expr_gen"")
    if dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr, err) is None:
        DERROR(""dwarf_add_AT_location_expr"")
    f_name = func.name
    if dwarf_add_AT_name(die, f_name, err) is None:
        DERROR(""dwarf_add_AT_name"")
    if dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name, err) is None:
        DERROR(""dwarf_add_AT_string"")

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die, err)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0, err)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0, err)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index, err)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line, err)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False, err)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None, err)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name, err)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None, err)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    if dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die, err) is None:
        DERROR(""dwarf_add_AT_reference child"")
    if dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length, err) is None:
        DERROR(""dwarf_add_AT_unsigned_const"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address, err)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None, err)
    record[struct.name] = die
    if dwarf_add_AT_name(die, struct.name.replace(""struct"", """"), err) is None:
        DERROR(""dwarf_add_AT_name"")
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length, err)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None, err)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die, err)
        dwarf_add_AT_name(member_die, c.fieldName, err)

        loc_expr = dwarf_new_expr(dbg, err)
        if dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0, err) == DW_DLV_NOCOUNT:
            DERROR(""dward_add_expr_gen"")

        if dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr, err) is None:
            DERROR(""dwarf_add_AT_location_expr"")
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg, err)
    if section_count == DW_DLV_NOCOUNT:
        DERROR(""dwarf_transform_to_disk_form"")
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length, err)
        if content is None:
            DERROR(""dwarf_get_section_bytes"")

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,d774bdaa24be8c55a4ea67ceee98e41b4ae22873,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/d774bdaa24be8c55a4ea67ceee98e41b4ae22873
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r
    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        dwarf_add_AT_name(cu, c_file_name)
        dir_index = dwarf_add_directory_decl(dbg, '.')
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
        dwarf_add_AT_comp_dir(cu, '.')

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,707db70c3a21670b956431dbb221b17580949bcd,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/707db70c3a21670b956431dbb221b17580949bcd
master,26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f,test.py,test_function,"def test_function():
    execute_cmd(""-file-exec-and-symbols ./test_dbg"")
    execute_cmd(""set listsize 1"")
    execute_cmd(""-break-insert 136"")
    execute_cmd(""-break-insert 142"")
    execute_cmd(""-exec-run"")

    execute_cmd(""c 2"")
    assert 2 == get_int(""i"")
    assert ""i = i + 1;"" == get_line(136)

    execute_cmd(""c 3"")
    d = get_struct(""*ex_2"")
    assert ""15"" == d[""x""]
    assert ""20"" == d[""y""]
    assert ""Example 1"" in d[""name""]

    assert 15 == get_int(""ex_2->x"")",https://www.github.com/cesena/ghidra2dwarf/commit/26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f
master,26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f,util.py,execute_cmd,"def execute_cmd(cmd: str, debug=False) -> list:
    response = gdbmi.write(cmd)
    if debug:
        pprint(response)
    return response",https://www.github.com/cesena/ghidra2dwarf/commit/26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f
master,26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f,util.py,get_struct,"def get_struct(var: str) -> dict:
    _, payload = get_payload(execute_cmd(f""print {var}"")).split(""{"")
    values = payload.split("", "")
    d = {}
    for v in values:
        key, value = v.split("" = "")
        if v == values[-1]:
            value = value.replace(""}\\n"", """")
        d[key] = value
    return d",https://www.github.com/cesena/ghidra2dwarf/commit/26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f
master,26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f,util.py,get_int,"def get_int(var: str) -> int:
    value = get_payload(execute_cmd(f""print {var}"")).replace(""\\n"", """")
    return int(value.split("" = "")[1])",https://www.github.com/cesena/ghidra2dwarf/commit/26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f
master,26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f,util.py,get_line,"def get_line(line: int) -> str:
    res = execute_cmd(f""list {line}"")
    _, payload = get_payload(res).split(f""{line}\\t"")
    return payload.replace(""\\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/26ebaf7af94b7eb8bedd4c1ebe1afc40d7e1633f
master,21d3390748246b71f3a33680e31970f8a1643eca,test_dbg.py,test_function,"def test_function():
    init(""./test_dbg"")
    execute_cmd(""-break-insert 136"")
    execute_cmd(""-break-insert 142"")
    execute_cmd(""-exec-run"")

    execute_cmd(""c 2"")
    assert 2 == get_int(""i"")
    assert ""i = i + 1;"" == get_line(136)

    execute_cmd(""c 3"")
    d = get_struct(""*ex_2"")
    assert ""15"" == d[""x""]
    assert ""20"" == d[""y""]
    assert ""Example 1"" in d[""name""]

    assert 15 == get_int(""ex_2->x"")

    assert ""print_example(ex_2);"" == get_line(144)",https://www.github.com/cesena/ghidra2dwarf/commit/21d3390748246b71f3a33680e31970f8a1643eca
master,21d3390748246b71f3a33680e31970f8a1643eca,util.py,execute_cmd,"def execute_cmd(cmd: str, debug=False) -> list:
    response = gdbmi.write(cmd)
    if debug:
        pprint(response)
    return response",https://www.github.com/cesena/ghidra2dwarf/commit/21d3390748246b71f3a33680e31970f8a1643eca
master,21d3390748246b71f3a33680e31970f8a1643eca,util.py,get_struct,"def get_struct(var: str) -> dict:
    _, payload = get_payload(execute_cmd(f""print {var}"")).split(""{"")
    values = payload.split("", "")
    d = {}
    for v in values:
        key, value = v.split("" = "")
        if v == values[-1]:
            value = value.replace(""}\\n"", """")
        d[key] = value
    return d",https://www.github.com/cesena/ghidra2dwarf/commit/21d3390748246b71f3a33680e31970f8a1643eca
master,21d3390748246b71f3a33680e31970f8a1643eca,util.py,get_int,"def get_int(var: str) -> int:
    value = get_payload(execute_cmd(f""print {var}"")).replace(""\\n"", """")
    return int(value.split("" = "")[1])",https://www.github.com/cesena/ghidra2dwarf/commit/21d3390748246b71f3a33680e31970f8a1643eca
master,21d3390748246b71f3a33680e31970f8a1643eca,util.py,get_line,"def get_line(line: int) -> str:
    res = execute_cmd(f""list {line}"")
    _, payload = get_payload(res).split(f""{line}\\t"")
    return payload.replace(""\\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/21d3390748246b71f3a33680e31970f8a1643eca
master,21d3390748246b71f3a33680e31970f8a1643eca,util.py,init,"def init(filename: str) -> None:
    execute_cmd(f""-file-exec-and-symbols {filename}"")
    execute_cmd(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/21d3390748246b71f3a33680e31970f8a1643eca
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r
    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        dwarf_add_AT_name(cu, c_file_name)
        dir_index = dwarf_add_directory_decl(dbg, '.')
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
        dwarf_add_AT_comp_dir(cu, '.')

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,a6a729da8419bc2b3a312686ace00120154f0eda,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/a6a729da8419bc2b3a312686ace00120154f0eda
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r
    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        dwarf_add_AT_name(cu, c_file_name)
        dir_index = dwarf_add_directory_decl(dbg, '.')
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
        dwarf_add_AT_comp_dir(cu, '.')

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,12c6ccae6610180626b574f198ff9039735ab133,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/12c6ccae6610180626b574f198ff9039735ab133
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r
    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        dwarf_add_AT_name(cu, c_file_name)
        dir_index = dwarf_add_directory_decl(dbg, '.')
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
        dwarf_add_AT_comp_dir(cu, '.')

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,f2baba455e8fea375fb30742e135bdb6c0a14264,test_ghidra.py,test_function,"def test_function():
    init(""./test_ghidra_dbg"")
    execute_cmd(""-break-insert 136"")
    execute_cmd(""-break-insert 142"")
    execute_cmd(""-exec-run"")

    execute_cmd(""c 2"")
    assert 2 == get_int(""i"")
    assert ""i = i + 1;"" == get_line(136)

    execute_cmd(""c 3"")
    d = get_struct(""*ex_2"")
    assert ""15"" == d[""x""]
    assert ""20"" == d[""y""]
    assert ""Example 1"" in d[""name""]

    assert 15 == get_int(""ex_2->x"")

    assert ""print_example(ex_2);"" == get_line(144)",https://www.github.com/cesena/ghidra2dwarf/commit/f2baba455e8fea375fb30742e135bdb6c0a14264
master,0e3a3d8eeed73f5143a94f846e45c2b78bee867d,util.py,execute_cmd,"def execute_cmd(cmd: str, debug=False) -> list:
    response = gdbmi.write(cmd)
    if debug:
        pprint(response)
    return response",https://www.github.com/cesena/ghidra2dwarf/commit/0e3a3d8eeed73f5143a94f846e45c2b78bee867d
master,0e3a3d8eeed73f5143a94f846e45c2b78bee867d,util.py,get_struct,"def get_struct(var: str) -> dict:
    _, payload = get_payload(execute_cmd(f""print {var}"")).split(""{"")
    values = payload.split("", "")
    d = {}
    for v in values:
        key, value = v.split("" = "")
        if v == values[-1]:
            value = value.replace(""}\\n"", """")
        d[key] = value
    return d",https://www.github.com/cesena/ghidra2dwarf/commit/0e3a3d8eeed73f5143a94f846e45c2b78bee867d
master,0e3a3d8eeed73f5143a94f846e45c2b78bee867d,util.py,get_int,"def get_int(var: str) -> int:
    value = get_payload(execute_cmd(f""print (unsigned int){var}"")).replace(""\\n"", """")
    return int(value.split("" = "")[1])",https://www.github.com/cesena/ghidra2dwarf/commit/0e3a3d8eeed73f5143a94f846e45c2b78bee867d
master,0e3a3d8eeed73f5143a94f846e45c2b78bee867d,util.py,get_line,"def get_line(line: int) -> str:
    res = execute_cmd(f""list {line}"")
    _, payload = get_payload(res).split(f""{line}\\t"")
    return payload.replace(""\\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/0e3a3d8eeed73f5143a94f846e45c2b78bee867d
master,0e3a3d8eeed73f5143a94f846e45c2b78bee867d,util.py,init,"def init(filename: str) -> None:
    execute_cmd(f""-file-exec-and-symbols {filename}"")
    execute_cmd(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/0e3a3d8eeed73f5143a94f846e45c2b78bee867d
master,774c4960a92835854f67a64379c8e2a94ba4ef92,test_dbg.py,test_function,"def test_function():
    init(""./test_ghidra_dbg"")
    execute_cmd(""-break-insert 136"")
    execute_cmd(""-break-insert 142"")
    execute_cmd(""-exec-run"")

    execute_cmd(""c 2"")
    assert 2 == get_int(""i"")
    assert ""i = i + 1;"" == get_line(136)

    execute_cmd(""c 3"")
    d = get_struct(""*ex_2"")
    assert ""15"" == d[""x""]
    assert ""20"" == d[""y""]
    assert ""Example 1"" in d[""name""]

    assert 15 == get_int(""ex_2->x"")

    assert ""print_example(ex_2);"" == get_line(144)",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,test_passcode.py,test_function,"def test_function():
    init(""./passcode_dbg"")
    execute_cmd(""-break-insert 193"")
    execute_cmd(""-break-insert 166"")
    execute_cmd(""r < ./passcode_input.txt"")

    assert 0x616161796161617861616177616161766161617561616174616161736161617261616171616161706161616f6161616e6161616d6161616c6161616b6161616a616161696161616861616167616161666161616561616164616161636161616261616161 == get_hex(""name"")
    execute_cmd(""c"")

    assert 0x61616179 == get_hex(""passcode1"")
    assert '__isoc99_scanf(&DAT_08048783,passcode1);' == get_line(166)",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,test_rsa.py,test_function,"def test_function():
    init(""./rsa_dbg"")
    execute_cmd(""-break-insert 434"")
    execute_cmd(""-exec-run"")

    assert 0xc5 == get_int(""local_ac0"")
    assert ""local_abf = 0xd6;"" == get_line(434)

    execute_cmd(""n"")
    assert 0xd6 == get_int(""local_abf"")",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,util.py,execute_cmd,"def execute_cmd(cmd: str, debug=False) -> list:
    response = gdbmi.write(cmd)
    if debug:
        pprint(response)
    return response",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,util.py,get_struct,"def get_struct(var: str) -> dict:
    _, payload = get_payload(execute_cmd(f""print {var}"")).split(""{"")
    values = payload.split("", "")
    d = {}
    for v in values:
        key, value = v.split("" = "")
        if v == values[-1]:
            value = value.replace(""}\\n"", """")
        d[key] = value
    return d",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,util.py,get_int,"def get_int(var: str) -> int:
    value = get_payload(execute_cmd(f""print (unsigned int){var}"")).replace(""\\n"", """")
    return int(value.split("" = "")[1])",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,util.py,get_hex,"def get_hex(var: str) -> int:
    value = get_payload(execute_cmd(f""p/x {var}"")).replace(""\\n"", """")
    return int(value.split("" = "")[1][2:], 16)",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,util.py,get_line,"def get_line(line: int) -> str:
    res = execute_cmd(f""list {line}"")
    _, payload = get_payload(res).split(f""{line}\\t"")
    return payload.replace(""\\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,774c4960a92835854f67a64379c8e2a94ba4ef92,util.py,init,"def init(filename: str) -> None:
    execute_cmd(f""-file-exec-and-symbols {filename}"")
    execute_cmd(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/774c4960a92835854f67a64379c8e2a94ba4ef92
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,test_passcode.py,test_function,"def test_function():
    init(""./passcode_dbg"")
    execute_cmd(""-break-insert 193"")
    execute_cmd(""-break-insert 166"")
    execute_cmd(""r < ./passcode_input.txt"")

    assert (
        0x616161796161617861616177616161766161617561616174616161736161617261616171616161706161616F6161616E6161616D6161616C6161616B6161616A616161696161616861616167616161666161616561616164616161636161616261616161
        == get_hex(""name"")
    )
    execute_cmd(""c"")

    assert 0x61616179 == get_hex(""passcode1"")
    assert ""__isoc99_scanf(&DAT_08048783,passcode1);"" == get_line(166)",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,test_rsa.py,test_function,"def test_function():
    init(""./rsa_dbg"")
    execute_cmd(""-break-insert 434"")
    execute_cmd(""-exec-run"")

    assert 0xC5 == get_int(""local_ac0"")
    assert ""local_abf = 0xd6;"" == get_line(434)

    execute_cmd(""n"")
    assert 0xD6 == get_int(""local_abf"")",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,util.py,execute_cmd,"def execute_cmd(cmd: str, debug=False) -> list:
    response = gdbmi.write(cmd)
    if debug:
        pprint(response)
    return response",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,util.py,get_struct,"def get_struct(var: str) -> dict:
    _, payload = get_payload(execute_cmd(f""print {var}"")).split(""{"")
    values = payload.split("", "")
    d = {}
    for v in values:
        key, value = v.split("" = "")
        if v == values[-1]:
            value = value.replace(""}\\n"", """")
        d[key] = value
    return d",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,util.py,get_int,"def get_int(var: str) -> int:
    value = get_payload(execute_cmd(f""print (unsigned int){var}"")).replace(""\\n"", """")
    return int(value.split("" = "")[1])",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,util.py,get_hex,"def get_hex(var: str) -> int:
    value = get_payload(execute_cmd(f""p/x {var}"")).replace(""\\n"", """")
    return int(value.split("" = "")[1][2:], 16)",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,util.py,get_line,"def get_line(line: int) -> str:
    res = execute_cmd(f""list {line}"")
    _, payload = get_payload(res).split(f""{line}\\t"")
    return payload.replace(""\\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a,util.py,init,"def init(filename: str) -> None:
    execute_cmd(f""-file-exec-and-symbols {filename}"")
    execute_cmd(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/d8b3eef0f2110fa0ac8aecb16e4e28cf5920950a
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,add_sections_to_elf,"def add_sections_to_elf(from_file, to_file, sections):
	with open(from_file, 'rb') as f:
		bb = f.read()
	e = Elf(bb)

	for name, s in sections:
		e.add_section(name, s)
	out = e.generate_updated_elf()
	with open(to_file, 'wb') as f:
		f.write(out)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__init__,"	def __init__(self, file_offset, map, values, **kwargs):
		self.__dict__['map'] = map
		self.file_offset = file_offset
		for n, v in zip(map, values):
			if isinstance(n, tuple):
				n, f = n
				v = f(v)
			setattr(self, n, v)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,values,"	def values(self):
		vv = (getattr(self, n[0] if isinstance(n, tuple) else n) for n in self.map)
		return [v.code if isinstance(v, DumbEnumValue) else v for v in vv]",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__setattr__,"	def __setattr__(self, name, value):
		if not hasattr(self, 'repr_pos'):
			object.__setattr__(self, 'repr_pos', {})
		if name not in self.repr_pos:
			self.repr_pos[name] = len(self.repr_pos)
		return object.__setattr__(self, name, value)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__repr__,"	def __repr__(self):
		args = ', '.join('%s=%r' % (n, getattr(self, n)) for n, _ in sorted(self.repr_pos.items(), key=lambda x: x[1]))
		return '%s(%s)' % (self.__class__.__name__, args)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			'magic',
			('elf_class', ElfClass.__getitem__),
			('elf_data', ElfData.__getitem__),
			'file_version',
			'osabi',
			'abi_version',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			('type', ET.__getitem__),
			('machine', EM.__getitem__),
			'version',
			'entry',
			'phoff',
			'shoff',
			'flags',
			'ehsize',
			'phentsize',
			'phnum',
			'shentsize',
			'shnum',
			'shstrndx',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__init__,"	def __init__(self, values, file_offset):
		self.name = ''
		return ElfBase.__init__(self, file_offset, [
			'name_offset',
			('type', SHT.__getitem__),
			'flags',
			'addr',
			'offset',
			'section_size',
			'link',
			'info',
			'addralign',
			'entsize',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__init__,"	def __init__(self, bytes):
		self.bytes = bytearray(bytes)
		self.extract_ident()
		bits = '64' if self.ident.elf_class == ElfClass.ELFCLASS64 else '32'
		#bits = '64' if ElfClass[self.ident.elf_class] == ElfClass.ELFCLASS64 else '32'
		endianness = 'le' if self.ident.elf_data == ElfData.ELFDATA2LSB else 'be'
		#endianness = 'le' if ElfData[self.ident.elf_data] == ElfData.ELFDATA2LSB else 'be'
		self.type = bits + endianness
		self.new_sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,_get_struct,"	def _get_struct(self, cls):
		s = struct_coders[cls.__name__]
		return s[self.type] if isinstance(s, dict) else s",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,_dump_struct,"	def _dump_struct(self, cls, off):
		s = self._get_struct(cls)
		# unpack_from doesn't work with jython
		# return cls(s.unpack_from(self.bytes, off), file_offset=off)
		bb = self.bytes[off:off+s.size]
		return cls(s.unpack(str(bb)), file_offset=off)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,_export_struct,"	def _export_struct(self, val, off):
		s = self._get_struct(val.__class__)
		# unpack_into doesn't work with jython
		# s.pack_into(self.bytes, off, *val.values)
		self.bytes[off:off+s.size] = s.pack(*val.values)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,extract_ident,"	def extract_ident(self):
		if hasattr(self, 'ident'):
			return self.ident
		self.ident = self._dump_struct(ElfIdent, 0)
		self.header_off = self._get_struct(ElfIdent).size
		return self.ident",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,extract_header,"	def extract_header(self):
		if hasattr(self, 'header'):
			return self.header
		self.header = self._dump_struct(ElfHeader, self.header_off)
		return self.header",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,extract_section_headers,"	def extract_section_headers(self):
		if hasattr(self, 'section_headers'):
			return self.section_headers

		self.section_headers = []
		h = self.extract_header()
		for i in range(h.shnum):
			self.section_headers.append(self._dump_struct(ElfSectionHeader, h.shoff + i * h.shentsize))
		self.section_names = self.extract_section(self.section_headers[h.shstrndx])
		for s in self.section_headers:
			s.name = self.section_names[s.name_offset:self.section_names.find('\x00', s.name_offset)]
		return self.section_headers",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,extract_section,"	def extract_section(self, section_header):
		return self.bytes[section_header.offset:section_header.offset+section_header.section_size]",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,encode_section_header,"	def encode_section_header(self, section_header):
		return self._get_struct(ElfSectionHeader).pack(*section_header.values)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,add_section,"	def add_section(self, name, body):
		self.new_sections.append((name, body))",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,generate_updated_elf,"	def generate_updated_elf(self):
		section_headers = self.extract_section_headers()
		added_sections = False
		for name, body in self.new_sections:
			try:
				s = next(s for s in section_headers if s.name == name)
			except:
				added_sections = True
				name_off = len(self.section_names)
				self.section_names += name + '\x00'
				s = ElfSectionHeader([name_off, 1, 0, 0, -1, -1, 0, 0, 1, 0], file_offset=-1)
				s.name = name
				section_headers.append(s)
			s.offset = len(self.bytes)
			s.section_size = len(body)
			self.bytes += body

		h = self.header
		if added_sections:
			shstr = section_headers[h.shstrndx]
			shstr.section_size = len(self.section_names)
			shstr.offset = len(self.bytes)
			self.bytes += self.section_names
			h.shoff = len(self.bytes)
			h.shnum = len(section_headers)
			self.bytes += '\x00' * h.shentsize * h.shnum

		self._export_struct(h, self.header_off)
		for i, s in enumerate(section_headers):
			s.file_offset = h.shoff + i * h.shentsize
			self._export_struct(s, s.file_offset)

		return self.bytes",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__init__,"	def __init__(self, name, code, desc): self.name, self.code, self.desc = name, code, desc",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__repr__,"	def __repr__(self): return '%s(%r, %r)' % (self.name, self.code, self.desc)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__init__,"		def __init__(cls, *args):
			cls._bycode = {}
			for n in dir(cls):
				if n[0] != '_':
					v = DumbEnumValue(n, *getattr(cls, n))
					setattr(cls, n, v)
					cls._bycode[v.code] = v",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,elf.py,__getitem__,"		def __getitem__(cls, idx):
			try:
				return cls._bycode[idx]
			except KeyError:
				raise Exception('enum %s has no entry with code %d.' % (cls.__name__, idx))",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,test_ghidra.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""test_ghidra_dbg"")
    gdb.breakpoint(136)
    gdb.breakpoint(142)
    gdb.execute_mi(""-exec-run"")

    gdb.execute_gdb(""c 2"")
    assert 2 == gdb.get_int(""i"")
    assert ""i = i + 1;"" == gdb.get_line(136)

    gdb.execute_gdb(""c 3"")
    d = gdb.get_struct(""*ex_2"")
    assert 15 == d[""x""]
    assert 20 == d[""y""]
    assert ""Example 1"" in d[""name""]

    assert 15 == gdb.get_int(""ex_2->x"")

    assert ""print_example(ex_2);"" == gdb.get_line(144)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,test_passcode.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""passcode_dbg"")
    gdb.breakpoint(193)
    gdb.breakpoint(166)

    NAME = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
    INPUT = f'{NAME} 1 2'
    gdb.execute_gdb(f""r < <(echo {INPUT})"")

    assert NAME == gdb.get_string(""name"")
    gdb.execute_gdb(""c"")

    assert 0x61616179 == gdb.get_int(""passcode1"")
    assert 'scanf' in gdb.get_line(166)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,test_rsa.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""rsa_dbg"")
    gdb.breakpoint(434)
    gdb.execute_mi(""-exec-run"")

    assert 0xc5 == gdb.get_int(""local_ac0"")
    assert ""local_abf = 0xd6;"" == gdb.get_line(434)

    gdb.execute_gdb(""n"")
    assert 0xd6 == gdb.get_int(""local_abf"")",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,__init__,"    def __init__(self, directory: str, filename: str, *, debug: bool = False) -> None:
        os.chmod(os.path.join(directory, filename), 0o755)
        self.gdbmi = GdbController()
        self.debug = debug
        self.execute_raw(f""cd {directory}"")
        self.execute_raw(f""-file-exec-and-symbols {filename}"")
        self.execute_raw(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,execute_raw,"    def execute_raw(self, cmd: str) -> list:
        self.gdbmi.write('')
        response = self.gdbmi.write(cmd)
        if self.debug:
            print('CMD:', cmd)
            pprint(response)
        return response",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,execute_mi,"    def execute_mi(self, cmd: str) -> dict:
        return self.execute_raw(cmd)[0]['payload']",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,breakpoint,"    def breakpoint(self, addr: int):
        return self.execute_mi(f'-break-insert {addr}')",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,execute_gdb,"    def execute_gdb(self, cmd: str) -> str:
        lines = dropwhile(lambda x: x['type'] != 'log', self.execute_raw(cmd))
        r = ''.join(x['payload'] for x in lines if x['type'] == 'console' and x['stream'] == 'stdout' and x['payload'])
        r = r.encode('utf-8').decode('unicode_escape')
        if self.debug:
            print(""RESP:"", r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,create_var,"    def create_var(self, name: str) -> dict:
        if isinstance(name, dict):
            return name
        out = self.execute_mi(f'-var-create - * ""{name}""')
        return out",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,var_to_python,"    def var_to_python(self, var: dict):
        t = var['type']
        if t == 'char *':
            return self.get_string(var)
        elif t[-1] == ']':
            return self.get_array(var)
        else:
            return self.get_int(var)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,get_list_children,"    def get_list_children(self, var: dict) -> list:
        # TODO: has_more?
        return self.execute_mi(f'-var-list-children {var[""name""]}')['children']",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,get_struct,"    def get_struct(self, expr: str) -> dict:
        var = self.create_var(expr)
        children = self.get_list_children(var)
        return {c['exp']: self.var_to_python(c) for c in children}",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,get_array,"    def get_array(self, expr: str) -> list:
        var = self.create_var(expr)
        return [self.var_to_python(c) for c in self.get_list_children(var)]",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,get_int,"    def get_int(self, expr: str) -> int:
        var = self.create_var(expr)
        value = self.var_evaluate(var, format='hexadecimal')
        return int(value, 16)",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,get_string,"    def get_string(self, expr: str) -> str:
        var = self.create_var(expr)
        value = self.var_evaluate(var)
        return value.split(' ', 1)[1].strip('""').encode('utf-8').decode('unicode_escape')",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,var_evaluate,"    def var_evaluate(self, var, *, format='natural') -> str:
        name = var['name'] if isinstance(var, dict) else var
        return self.execute_mi(f'-var-evaluate-expression -f {format} {name}')['value']",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,b7a79f16aa7b2325e3fa2890ebc76f2378541648,util.py,get_line,"    def get_line(self, line: int) -> str:
        res = self.execute_gdb(f""list {line}"")
        _, payload = res.split(f""{line}\t"")
        return payload.replace(""\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/b7a79f16aa7b2325e3fa2890ebc76f2378541648
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r
    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        dwarf_add_AT_name(cu, c_file_name)
        dir_index = dwarf_add_directory_decl(dbg, '.')
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
        dwarf_add_AT_comp_dir(cu, '.')

    for f in get_functions():
        if is_function_executable(f):
            add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            #dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    # TODO
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split('\n'))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write('\n'.join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, ArrayDataType):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    assert ""pointer"" in t.description
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    child_die = add_type(cu, t.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = ''
        sections[section_name] += content    
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err, )))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,ab259a93472e0a146bce604159ef36053ea8cb35,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/ab259a93472e0a146bce604159ef36053ea8cb35
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,test_ghidra.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""test_ghidra_dbg"")
    gdb.breakpoint(136)
    gdb.breakpoint(142)
    gdb.execute_mi(""-exec-run"")

    gdb.execute_gdb(""c 2"")
    assert 2 == gdb.get_int(""i"")
    assert ""i = i + 1;"" == gdb.get_line(136)

    gdb.execute_gdb(""c 3"")
    d = gdb.get_struct(""*ex_2"")
    assert 15 == d[""x""]
    assert 20 == d[""y""]
    assert ""Example 1"" in d[""name""]

    assert 15 == gdb.get_int(""ex_2->x"")

    assert ""print_example(ex_2);"" == gdb.get_line(144)",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,test_passcode.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""passcode_dbg"")
    gdb.breakpoint(193)
    gdb.breakpoint(166)

    NAME = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
    INPUT = f'{NAME} 1 2'
    gdb.execute_gdb(f""r < <(echo {INPUT})"")

    assert NAME == gdb.get_string(""(char *)name"")
    gdb.execute_gdb(""c"")

    assert 0x61616179 == gdb.get_int(""passcode1"")
    assert 'scanf' in gdb.get_line(166)",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,test_rsa.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""rsa_dbg"")
    gdb.breakpoint(434)
    gdb.execute_mi(""-exec-run"")

    assert 0xC5 == gdb.get_int(""local_ac0"")
    assert ""local_abf = 0xd6;"" == gdb.get_line(434)

    gdb.execute_gdb(""n"")
    assert 0xD6 == gdb.get_int(""local_abf"")",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,__init__,"    def __init__(self, directory: str, filename: str, *, debug: bool = False) -> None:
        os.chmod(os.path.join(directory, filename), 0o755)
        self.gdbmi = GdbController()
        self.debug = debug
        self.execute_raw(f""cd {directory}"")
        self.execute_raw(f""-file-exec-and-symbols {filename}"")
        self.execute_raw(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,execute_raw,"    def execute_raw(self, cmd: str) -> list:
        self.gdbmi.write("""")
        response = self.gdbmi.write(cmd)
        if self.debug:
            print(""CMD:"", cmd)
            pprint(response)
        return response",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,execute_mi,"    def execute_mi(self, cmd: str) -> dict:
        return self.execute_raw(cmd)[0][""payload""]",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,breakpoint,"    def breakpoint(self, addr: int):
        return self.execute_mi(f""-break-insert {addr}"")",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,execute_gdb,"    def execute_gdb(self, cmd: str) -> str:
        lines = dropwhile(lambda x: x[""type""] != ""log"", self.execute_raw(cmd))
        r = """".join(x[""payload""] for x in lines if x[""type""] == ""console"" and x[""stream""] == ""stdout"" and x[""payload""])
        r = r.encode(""utf-8"").decode(""unicode_escape"")
        if self.debug:
            print(""RESP:"", r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,create_var,"    def create_var(self, name: str) -> dict:
        if isinstance(name, dict):
            return name
        out = self.execute_mi(f'-var-create - * ""{name}""')
        return out",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,var_to_python,"    def var_to_python(self, var: dict):
        t = var[""type""]
        if t == ""char *"":
            return self.get_string(var)
        elif t[-1] == ""]"":
            return self.get_array(var)
        else:
            return self.get_int(var)",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,get_list_children,"    def get_list_children(self, var: dict) -> list:
        # TODO: has_more?
        return self.execute_mi(f'-var-list-children {var[""name""]}')[""children""]",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,get_struct,"    def get_struct(self, expr: str) -> dict:
        var = self.create_var(expr)
        children = self.get_list_children(var)
        return {c[""exp""]: self.var_to_python(c) for c in children}",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,get_array,"    def get_array(self, expr: str) -> list:
        var = self.create_var(expr)
        return [self.var_to_python(c) for c in self.get_list_children(var)]",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,get_int,"    def get_int(self, expr: str) -> int:
        var = self.create_var(expr)
        value = self.var_evaluate(var, format=""hexadecimal"")
        return int(value, 16)",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,get_string,"    def get_string(self, expr: str) -> str:
        var = self.create_var(expr)
        value = self.var_evaluate(var)
        return value.split("" "", 1)[1].strip('""').encode(""utf-8"").decode(""unicode_escape"")",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,var_evaluate,"    def var_evaluate(self, var, *, format=""natural"") -> str:
        name = var[""name""] if isinstance(var, dict) else var
        return self.execute_mi(f""-var-evaluate-expression -f {format} {name}"")[""value""]",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,1da16c9a0e84f2f44d96dd1314df14b58d06a73d,util.py,get_line,"    def get_line(self, line: int) -> str:
        res = self.execute_gdb(f""list {line}"")
        _, payload = res.split(f""{line}\t"")
        return payload.replace(""\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/1da16c9a0e84f2f44d96dd1314df14b58d06a73d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,test_passcode.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""passcode_dbg"", debug=True)
    gdb.breakpoint(193)
    gdb.breakpoint(166)

    NAME = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
    INPUT = f'{NAME} 1 2'
    gdb.run(args='dkjasl as', stdin=INPUT)

    assert NAME == gdb.get_string(""(char *)name"")
    gdb.execute_gdb(""c"")

    assert 0x61616179 == gdb.get_int(""passcode1"")
    assert 'scanf' in gdb.get_line(166)",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,__init__,"    def __init__(self, directory: str, filename: str, *, debug: bool = False) -> None:
        os.chmod(os.path.join(directory, filename), 0o755)
        self.gdbmi = GdbController()
        self.debug = debug
        self.execute_raw(f""cd {directory}"")
        self.execute_raw(f""-file-exec-and-symbols {filename}"")
        self.execute_raw(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,execute_raw,"    def execute_raw(self, cmd: str) -> list:
        self.gdbmi.write("""")
        response = self.gdbmi.write(cmd)
        if self.debug:
            print(""CMD:"", cmd)
            pprint(response)
        return response",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,execute_mi,"    def execute_mi(self, cmd: str) -> dict:
        return self.execute_raw(cmd)[0][""payload""]",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,execute_gdb,"    def execute_gdb(self, cmd: str) -> str:
        lines = dropwhile(lambda x: x[""type""] != ""log"", self.execute_raw(cmd))
        r = """".join(x[""payload""] for x in lines if x[""type""] == ""console"" and x[""stream""] == ""stdout"" and x[""payload""])
        r = r.encode(""utf-8"").decode(""unicode_escape"")
        if self.debug:
            print(""RESP:"", r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,run,"    def run(self, *, args='', stdin=''):
        cmd = f'run'
        if args:
            cmd += f' {args}'
        if stdin:
            self.f_stdin = tempfile.NamedTemporaryFile(prefix='g2d_stdin_')
            self.f_stdin.write(stdin.encode())
            self.f_stdin.flush()
            cmd += f' < {self.f_stdin.name}'
        return self.execute_gdb(cmd)",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,__del__,"    def __del__(self):
        if hasattr(self, 'f_stdin'):
            self.f_stdin.close()",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,breakpoint,"    def breakpoint(self, addr: int):
        return self.execute_mi(f""-break-insert {addr}"")",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,create_var,"    def create_var(self, name: str) -> dict:
        if isinstance(name, dict):
            return name
        out = self.execute_mi(f'-var-create - * ""{name}""')
        return out",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,var_to_python,"    def var_to_python(self, var: dict):
        t = var[""type""]
        if t == ""char *"":
            return self.get_string(var)
        elif t[-1] == ""]"":
            return self.get_array(var)
        else:
            return self.get_int(var)",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,get_list_children,"    def get_list_children(self, var: dict) -> list:
        # TODO: has_more?
        return self.execute_mi(f'-var-list-children {var[""name""]}')[""children""]",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,get_struct,"    def get_struct(self, expr: str) -> dict:
        var = self.create_var(expr)
        children = self.get_list_children(var)
        return {c[""exp""]: self.var_to_python(c) for c in children}",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,get_array,"    def get_array(self, expr: str) -> list:
        var = self.create_var(expr)
        return [self.var_to_python(c) for c in self.get_list_children(var)]",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,get_int,"    def get_int(self, expr: str) -> int:
        var = self.create_var(expr)
        value = self.var_evaluate(var, format=""hexadecimal"")
        return int(value, 16)",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,get_string,"    def get_string(self, expr: str) -> str:
        var = self.create_var(expr)
        value = self.var_evaluate(var)
        return value.split("" "", 1)[1].strip('""').encode(""utf-8"").decode(""unicode_escape"")",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,var_evaluate,"    def var_evaluate(self, var, *, format=""natural"") -> str:
        name = var[""name""] if isinstance(var, dict) else var
        return self.execute_mi(f""-var-evaluate-expression -f {format} {name}"")[""value""]",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,2a38cc8dc4f24decf544c88f64e64927aa02329d,util.py,get_line,"    def get_line(self, line: int) -> str:
        res = self.execute_gdb(f""list {line}"")
        _, payload = res.split(f""{line}\t"")
        return payload.replace(""\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/2a38cc8dc4f24decf544c88f64e64927aa02329d
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,__init__,"    def __init__(self, directory: str, filename: str, *, debug: bool = False) -> None:
        os.chmod(os.path.join(directory, filename), 0o755)
        self.gdbmi = GdbController()
        self.debug = debug
        self.execute_raw(f""cd {directory}"")
        self.execute_raw(f""-file-exec-and-symbols {filename}"")
        self.execute_raw(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,execute_raw,"    def execute_raw(self, cmd: str) -> list:
        # this is needed to clean up gdb output
        self.gdbmi.get_gdb_response(timeout_sec=0, raise_error_on_timeout=False)
        response = self.gdbmi.write(cmd)
        if self.debug:
            print(""CMD:"", cmd)
            pprint(response)
        return response",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,execute_mi,"    def execute_mi(self, cmd: str) -> dict:
        return self.execute_raw(cmd)[0][""payload""]",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,execute_gdb,"    def execute_gdb(self, cmd: str) -> str:
        lines = dropwhile(lambda x: x[""type""] != ""log"", self.execute_raw(cmd))
        r = """".join(x[""payload""] for x in lines if x[""type""] == ""console"" and x[""stream""] == ""stdout"" and x[""payload""])
        r = r.encode(""utf-8"").decode(""unicode_escape"")
        if self.debug:
            print(""RESP:"", r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,run,"    def run(self, *, args='', stdin=''):
        cmd = f'run'
        if args:
            cmd += f' {args}'
        if stdin:
            self.f_stdin = tempfile.NamedTemporaryFile(prefix='g2d_stdin_')
            self.f_stdin.write(stdin.encode())
            self.f_stdin.flush()
            cmd += f' < {self.f_stdin.name}'
        return self.execute_gdb(cmd)",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,__del__,"    def __del__(self):
        if hasattr(self, 'f_stdin'):
            self.f_stdin.close()",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,breakpoint,"    def breakpoint(self, addr: int):
        return self.execute_mi(f""-break-insert {addr}"")",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,create_var,"    def create_var(self, name: str) -> dict:
        if isinstance(name, dict):
            return name
        out = self.execute_mi(f'-var-create - * ""{name}""')
        return out",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,var_to_python,"    def var_to_python(self, var: dict):
        t = var[""type""]
        if t == ""char *"":
            return self.get_string(var)
        elif t[-1] == ""]"":
            return self.get_array(var)
        else:
            return self.get_int(var)",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,get_list_children,"    def get_list_children(self, var: dict) -> list:
        # TODO: has_more?
        return self.execute_mi(f'-var-list-children {var[""name""]}')[""children""]",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,get_struct,"    def get_struct(self, expr: str) -> dict:
        var = self.create_var(expr)
        children = self.get_list_children(var)
        return {c[""exp""]: self.var_to_python(c) for c in children}",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,get_array,"    def get_array(self, expr: str) -> list:
        var = self.create_var(expr)
        return [self.var_to_python(c) for c in self.get_list_children(var)]",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,get_int,"    def get_int(self, expr: str) -> int:
        var = self.create_var(expr)
        value = self.var_evaluate(var, format=""hexadecimal"")
        return int(value, 16)",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,get_string,"    def get_string(self, expr: str) -> str:
        var = self.create_var(expr)
        value = self.var_evaluate(var)
        return value.split("" "", 1)[1].strip('""').encode(""utf-8"").decode(""unicode_escape"")",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,var_evaluate,"    def var_evaluate(self, var, *, format=""natural"") -> str:
        name = var[""name""] if isinstance(var, dict) else var
        return self.execute_mi(f""-var-evaluate-expression -f {format} {name}"")[""value""]",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,d0efe39d61ce0fa01e9208dc623703d7955d343e,util.py,get_line,"    def get_line(self, line: int) -> str:
        res = self.execute_gdb(f""list {line}"")
        _, payload = res.split(f""{line}\t"")
        return payload.replace(""\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/d0efe39d61ce0fa01e9208dc623703d7955d343e
master,02f54951595a54e1c6cf51414288ec9314d92501,test_ghidra.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""test_ghidra_dbg"", debug=True)
    gdb.breakpoint(136)
    gdb.breakpoint(142)
    gdb.run()

    gdb.execute_raw(""c 2"")
    assert 2 == gdb.get_int(""i"")
    assert ""i = i + 1;"" == gdb.get_line(136)

    gdb.execute_raw(""c 3"")
    d = gdb.get_struct(""*ex_2"")
    assert 15 == d[""x""]
    assert 20 == d[""y""]
    assert ""Example 1"" in d[""name""]

    assert 15 == gdb.get_int(""ex_2->x"")

    assert ""print_example(ex_2);"" == gdb.get_line(144)",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,test_passcode.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""passcode_dbg"", debug=True)
    gdb.breakpoint(193)
    gdb.breakpoint(166)

    NAME = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
    INPUT = f'{NAME} 1 2'
    gdb.run(stdin=INPUT)

    assert NAME == gdb.get_string(""(char *)name"")
    gdb.execute_raw(""c"")

    assert 0x61616179 == gdb.get_int(""passcode1"")
    assert 'scanf' in gdb.get_line(166)",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,test_rsa.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""rsa_dbg"", debug=False)
    gdb.breakpoint(434)
    gdb.run()

    assert 0xC5 == gdb.get_int(""local_ac0"")
    assert ""local_abf = 0xd6;"" == gdb.get_line(434)

    gdb.execute_raw(""n"")
    assert 0xD6 == gdb.get_int(""local_abf"")",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,__init__,"    def __init__(self, directory: str, filename: str, *, debug: bool = False) -> None:
        os.chmod(os.path.join(directory, filename), 0o755)
        self.gdbmi = GdbController()
        self.debug = debug
        self.execute_raw(f""cd {directory}"")
        self.execute_raw(f""-file-exec-and-symbols {filename}"")
        self.execute_raw(""set listsize 1"")",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,execute_raw,"    def execute_raw(self, cmd: str) -> list:
        response = self.gdbmi.write(cmd)
        if self.debug:
            print(""CMD:"", cmd)
            pprint(response)
        return response",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,execute_mi,"    def execute_mi(self, cmd: str) -> dict:
        try:
            resp = next(x for x in self.execute_raw(cmd) if x[""message""] == ""done"")
            return resp[""payload""]
        except:
            raise Exception(f""The command {repr(cmd)} did not return a value."")",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,execute_gdb,"    def execute_gdb(self, cmd: str) -> str:
        lines = dropwhile(lambda x: x[""type""] != ""log"", self.execute_raw(cmd))
        r = """".join(x[""payload""] for x in lines if x[""type""] == ""console"" and x[""stream""] == ""stdout"" and x[""payload""])
        r = r.encode(""utf-8"").decode(""unicode_escape"")
        if self.debug:
            print(""RESP:"", r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,_run_or_start,"    def _run_or_start(self, what: str, args: str, stdin: str):
        cmd = what
        if args:
            cmd += f' {args}'
        if stdin:
            self.f_stdin = tempfile.NamedTemporaryFile(prefix='g2d_stdin_')
            self.f_stdin.write(stdin.encode())
            self.f_stdin.flush()
            cmd += f' < {self.f_stdin.name}'
        return self.execute_raw(cmd)",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,__del__,"    def __del__(self):
        if hasattr(self, 'f_stdin'):
            self.f_stdin.close()",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,run,"    def run(self, *, args: str='', stdin: str=''):
        return self._run_or_start('run', args=args, stdin=stdin)",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,start,"    def start(self, *, args: str='', stdin: str=''):
        return self._run_or_start('start', args=args, stdin=stdin)",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,breakpoint,"    def breakpoint(self, addr: int):
        return self.execute_mi(f""-break-insert {addr}"")",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,create_var,"    def create_var(self, name: str) -> dict:
        if isinstance(name, dict):
            return name
        out = self.execute_mi(f'-var-create - * ""{name}""')
        return out",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,var_to_python,"    def var_to_python(self, var: dict):
        t = var[""type""]
        if t == ""char *"":
            return self.get_string(var)
        elif t[-1] == ""]"":
            return self.get_array(var)
        else:
            return self.get_int(var)",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,get_list_children,"    def get_list_children(self, var: dict) -> list:
        # TODO: has_more?
        return self.execute_mi(f'-var-list-children {var[""name""]}')[""children""]",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,get_struct,"    def get_struct(self, expr: str) -> dict:
        var = self.create_var(expr)
        children = self.get_list_children(var)
        return {c[""exp""]: self.var_to_python(c) for c in children}",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,get_array,"    def get_array(self, expr: str) -> list:
        var = self.create_var(expr)
        return [self.var_to_python(c) for c in self.get_list_children(var)]",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,get_int,"    def get_int(self, expr: str) -> int:
        var = self.create_var(expr)
        value = self.var_evaluate(var, format=""hexadecimal"")
        return int(value, 16)",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,get_string,"    def get_string(self, expr: str) -> str:
        var = self.create_var(expr)
        value = self.var_evaluate(var)
        return value.split("" "", 1)[1].strip('""').encode(""utf-8"").decode(""unicode_escape"")",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,var_evaluate,"    def var_evaluate(self, var, *, format=""natural"") -> str:
        name = var[""name""] if isinstance(var, dict) else var
        return self.execute_mi(f""-var-evaluate-expression -f {format} {name}"")[""value""]",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,02f54951595a54e1c6cf51414288ec9314d92501,util.py,get_line,"    def get_line(self, line: int) -> str:
        res = self.execute_gdb(f""list {line}"")
        _, payload = res.split(f""{line}\t"")
        return payload.replace(""\n"", """").strip()",https://www.github.com/cesena/ghidra2dwarf/commit/02f54951595a54e1c6cf51414288ec9314d92501
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)
    if options.use_decompiler:
        c_file_name = os.path.split(decompiled_c_path)[1]
        dwarf_add_AT_name(cu, c_file_name)
        dir_index = dwarf_add_directory_decl(dbg, ""."")
        file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
        dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)
        pass
        # results = ifc.decompileFunction(f, 0, ConsoleTaskMonitor())
        # print (results.getDecompiledFunction().getC())
    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(False):
        # TODO: What is GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    if options.use_decompiler:
        func_line = len(decomp_lines) + 1

        res = get_decompiled_function(func)
        d = res.decompiledFunction.c
        decomp_lines.extend(d.split(""\n""))

        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
        dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
        dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
        add_decompiler_func_info(cu, die, func, file_index, func_line)
    else:
        # TODO: NEVER?
        # add_disassembler_func_info(cu, die, func)
        pass
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if record.get(t.name, 0) != 0:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # pointer doesn't have child
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,__init__,"    def __init__(self, use_dec=False, only_dec_nam_fun=False, att_deb_inf=False, verbose=False):
        self.use_decompiler = use_dec
        self.only_decompile_named_funcs = only_dec_nam_fun
        self.attach_debug_info = att_deb_inf
        self.verbose = verbose
        self.filepath = """"
        self.filename = """"
        self.dwarf_source_path = """"
        self.export_options = 0",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,efbee4ce2b07ca500c25682d6d334a86365119b9,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/efbee4ce2b07ca500c25682d6d334a86365119b9
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(False):
        # TODO: What is GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    """"""
    # TODO: Is this useless?
    Add all the structures defined in Ghidra, since every variable decompiled has already
    a type associated, this function probably is useless

    It corrupts the .debug_info section
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)
    """"""
    pass",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,c71511dc9ccb8fbcec6c5960f1f7e674c285a679,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/c71511dc9ccb8fbcec6c5960f1f7e674c285a679
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # TODO: Sometimes error with custom types?
        try:
            yield s.name, hv.dataType, s.PCAddress, hv.storage
        except:
            pass",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(False):
        # TODO: What is GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,2d11fd77a5f03de04b8fb20bd78218d132afab80,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/2d11fd77a5f03de04b8fb20bd78218d132afab80
master,b1b02748628a8d3e5d0458d804ffb10e4fb11b78,test_passcode.py,test_function,"def test_function():
    gdb = Gdb(""binaries"", ""passcode_dbg"", debug=True)
    gdb.breakpoint(193)
    gdb.breakpoint(166)

    NAME = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
    INPUT = f'{NAME} 1 2'
    gdb.run(stdin=INPUT)

    assert NAME == gdb.get_string(""(char *)name"")
    gdb.execute_raw(""c"")

    assert 0x61616179 == gdb.get_int(""passcode1"")
    assert 'scanf' in gdb.get_line(166)",https://www.github.com/cesena/ghidra2dwarf/commit/b1b02748628a8d3e5d0458d804ffb10e4fb11b78
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        hv = s.highVariable
        # print(s.name, s.PCAddress, type(hv))
        if hv:
            yield s.name, hv.dataType, s.PCAddress, hv.storage",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(False):
        # TODO: What is GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,714f4f9d375a0c57a9b0a88e69a2d661fe1886dc,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/714f4f9d375a0c57a9b0a88e69a2d661fe1886dc
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        if s.dataType:
            # print(s.name)
            yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        lowest_addr = min(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(False):
        # TODO: What is GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,6983e91101b96c68a07cc35c8c3a223901242ebb,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/6983e91101b96c68a07cc35c8c3a223901242ebb
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        if s.dataType:
            # print(s.name)
            yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        lowest_addr = max(addresses) if addresses else None

        if lowest_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, lowest_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(False):
        # TODO: What is GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,47a2f299c1d815b962d0077e5f9fb4eeeabe557a,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/47a2f299c1d815b962d0077e5f9fb4eeeabe557a
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        if s.dataType:
            # print(s.name)
            yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(False):
        # TODO: What is GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,e0e071b241de6c6914db2e244d02ab5300d7ed78,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/e0e071b241de6c6914db2e244d02ab5300d7ed78
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        if s.dataType:
            # print(s.name)
            yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,40f6401ffdd1d7489ac62943b2c956c30fa2f578,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/40f6401ffdd1d7489ac62943b2c956c30fa2f578
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,ad9599bf3c34a572f20b1638f62f845da6f13a1b,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/ad9599bf3c34a572f20b1638f62f845da6f13a1b
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,22489e5c3bef7c01f45265157d6a14d0bb0caa15,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/22489e5c3bef7c01f45265157d6a14d0bb0caa15
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,add_sections_to_elf,"def add_sections_to_elf(from_file, to_file, sections):
	with open(from_file, 'rb') as f:
		bb = f.read()
	e = Elf(bb)

	for name, s in sections:
		e.add_section(name, s)
	out = e.generate_updated_elf()
	with open(to_file, 'wb') as f:
		f.write(out)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__init__,"	def __init__(self, file_offset, map, values, **kwargs):
		self.__dict__['map'] = map
		self.file_offset = file_offset
		for n, v in zip(map, values):
			if isinstance(n, tuple):
				n, f = n
				v = f(v)
			setattr(self, n, v)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,values,"	def values(self):
		vv = (getattr(self, n[0] if isinstance(n, tuple) else n) for n in self.map)
		return [v.code if isinstance(v, DumbEnumValue) else v for v in vv]",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__setattr__,"	def __setattr__(self, name, value):
		if not hasattr(self, 'repr_pos'):
			object.__setattr__(self, 'repr_pos', {})
		if name not in self.repr_pos:
			self.repr_pos[name] = len(self.repr_pos)
		return object.__setattr__(self, name, value)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__repr__,"	def __repr__(self):
		args = ', '.join('%s=%r' % (n, getattr(self, n)) for n, _ in sorted(self.repr_pos.items(), key=lambda x: x[1]))
		return '%s(%s)' % (self.__class__.__name__, args)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			'magic',
			('elf_class', ElfClass.__getitem__),
			('elf_data', ElfData.__getitem__),
			'file_version',
			'osabi',
			'abi_version',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			('type', ET.__getitem__),
			('machine', EM.__getitem__),
			'version',
			'entry',
			'phoff',
			'shoff',
			'flags',
			'ehsize',
			'phentsize',
			'phnum',
			'shentsize',
			'shnum',
			'shstrndx',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__init__,"	def __init__(self, values, file_offset):
		self.name = ''
		return ElfBase.__init__(self, file_offset, [
			'name_offset',
			('type', SHT.__getitem__),
			'flags',
			'addr',
			'offset',
			'section_size',
			'link',
			'info',
			'addralign',
			'entsize',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__init__,"	def __init__(self, bytes):
		self.bytes = bytearray(bytes)
		self.extract_ident()
		bits = '64' if self.ident.elf_class == ElfClass.ELFCLASS64 else '32'
		#bits = '64' if ElfClass[self.ident.elf_class] == ElfClass.ELFCLASS64 else '32'
		endianness = 'le' if self.ident.elf_data == ElfData.ELFDATA2LSB else 'be'
		#endianness = 'le' if ElfData[self.ident.elf_data] == ElfData.ELFDATA2LSB else 'be'
		self.type = bits + endianness
		self.new_sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,_get_struct,"	def _get_struct(self, cls):
		s = struct_coders[cls.__name__]
		return s[self.type] if isinstance(s, dict) else s",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,_dump_struct,"	def _dump_struct(self, cls, off):
		s = self._get_struct(cls)
		# unpack_from doesn't work with jython
		# return cls(s.unpack_from(self.bytes, off), file_offset=off)
		bb = self.bytes[off:off+s.size]
		return cls(s.unpack(str(bb)), file_offset=off)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,_export_struct,"	def _export_struct(self, val, off):
		s = self._get_struct(val.__class__)
		# unpack_into doesn't work with jython
		# s.pack_into(self.bytes, off, *val.values)
		self.bytes[off:off+s.size] = s.pack(*val.values)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,extract_ident,"	def extract_ident(self):
		if hasattr(self, 'ident'):
			return self.ident
		self.ident = self._dump_struct(ElfIdent, 0)
		self.header_off = self._get_struct(ElfIdent).size
		return self.ident",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,extract_header,"	def extract_header(self):
		if hasattr(self, 'header'):
			return self.header
		self.header = self._dump_struct(ElfHeader, self.header_off)
		return self.header",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,extract_section_headers,"	def extract_section_headers(self):
		if hasattr(self, 'section_headers'):
			return self.section_headers

		self.section_headers = []
		h = self.extract_header()
		for i in range(h.shnum):
			self.section_headers.append(self._dump_struct(ElfSectionHeader, h.shoff + i * h.shentsize))
		self.section_names = self.extract_section(self.section_headers[h.shstrndx])
		for s in self.section_headers:
			s.name = self.section_names[s.name_offset:self.section_names.find('\x00', s.name_offset)]
		return self.section_headers",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,extract_section,"	def extract_section(self, section_header):
		return self.bytes[section_header.offset:section_header.offset+section_header.section_size]",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,encode_section_header,"	def encode_section_header(self, section_header):
		return self._get_struct(ElfSectionHeader).pack(*section_header.values)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,add_section,"	def add_section(self, name, body):
		self.new_sections.append((name, body))",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,generate_updated_elf,"	def generate_updated_elf(self):
		section_headers = self.extract_section_headers()
		added_sections = False
		for name, body in self.new_sections:
			try:
				s = next(s for s in section_headers if s.name == name)
			except:
				added_sections = True
				name_off = len(self.section_names)
				self.section_names += name + '\x00'
				s = ElfSectionHeader([name_off, 1, 0, 0, -1, -1, 0, 0, 1, 0], file_offset=-1)
				s.name = name
				section_headers.append(s)
			s.offset = len(self.bytes)
			s.section_size = len(body)
			self.bytes += body

		h = self.header
		if added_sections:
			shstr = section_headers[h.shstrndx]
			shstr.section_size = len(self.section_names)
			shstr.offset = len(self.bytes)
			self.bytes += self.section_names
			h.shoff = len(self.bytes)
			h.shnum = len(section_headers)
			self.bytes += '\x00' * h.shentsize * h.shnum

		self._export_struct(h, self.header_off)
		for i, s in enumerate(section_headers):
			s.file_offset = h.shoff + i * h.shentsize
			self._export_struct(s, s.file_offset)

		return self.bytes",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__init__,"	def __init__(self, name, code, desc): self.name, self.code, self.desc = name, code, desc",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__repr__,"	def __repr__(self): return '%s(%r, %r)' % (self.name, self.code, self.desc)",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__init__,"		def __init__(cls, *args):
			cls._bycode = {}
			for n in dir(cls):
				if n[0] != '_':
					v = DumbEnumValue(n, *getattr(cls, n))
					setattr(cls, n, v)
					cls._bycode[v.code] = v",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720,elf.py,__getitem__,"		def __getitem__(cls, idx):
			try:
				return cls._bycode[idx]
			except KeyError:
				raise Exception('enum %s has no entry with code %d.' % (cls.__name__, idx))",https://www.github.com/cesena/ghidra2dwarf/commit/07fcf1a3ed2adcc36bc0cd1e6eeb1e101cdd4720
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,f1c41191ce2304950200303a287296f30dc8e61f,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/f1c41191ce2304950200303a287296f30dc8e61f
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,6c992bb77d22d9737f8d53d5993a96fe0fa33c5e,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/6c992bb77d22d9737f8d53d5993a96fe0fa33c5e
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    for s in hf.localSymbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    var_die = dwarf_new_die(dbg, DW_TAG_variable, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    t = func.returnType
    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,e6b33e547f2137d832f586d1c1ea6e03802ec616,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/e6b33e547f2137d832f586d1c1ea6e03802ec616
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    for f in get_functions():
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    decomp = get_decompiled_function(func)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,7f8fd8fb7079efc5f672565402a011d5455e9122,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/7f8fd8fb7079efc5f672565402a011d5455e9122
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, res, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/98c84ef2bdfeeb138ee4500e8594fe7bc24a84ad
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    add_decompiler_func_info(cu, die, func, res, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,d02891a078b7e7f62d42a0828f87d51691a59cfc,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/d02891a078b7e7f62d42a0828f87d51691a59cfc
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    if res.decompiledFunction is None:
        d = ""/* Error decompiling %s: %s */"" % (func.getName(True), res.errorMessage)
    else:
        d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    if res.decompiledFunction is not None:
        add_decompiler_func_info(cu, die, func, res, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,8a9a6b89db467016198739a570bf4cdfbffe8c1f,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/8a9a6b89db467016198739a570bf4cdfbffe8c1f
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    if res.decompiledFunction is None:
        d = ""/* Error decompiling %s: %s */"" % (func.getName(True), res.errorMessage)
    else:
        d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    if res.decompiledFunction is not None:
        add_decompiler_func_info(cu, die, func, res, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines))",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,17d5328d593dda8dfb8d240da74ee59fd5488d15,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/17d5328d593dda8dfb8d240da74ee59fd5488d15
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        add_function(cu, f, file_index)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    for l in lines:
        # TODO: multiple lines might have the same lowest address
        addresses = [get_real_address(t.minAddress) for t in l.allTokens if t.minAddress]
        # TODO: We need to use max or min? In some cases with min we have incorrect offset
        best_addr = addresses[0] if addresses else None

        if best_addr:
            # TODO: is this call to dwarf_lne_set_address needed?
            # dwarf_lne_set_address(dbg, lowest_line_addr, 0)
            # https://nxmnpg.lemoda.net/3/dwarf_add_line_entry
            dwarf_add_line_entry(dbg, file_index, best_addr, l.lineNumber + func_line - 1, 0, True, False)",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    if res.decompiledFunction is None:
        d = ""/* Error decompiling %s: %s */"" % (func.getName(True), res.errorMessage)
    else:
        d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    dwarf_add_line_entry(dbg, file_index, f_start, func_line, 0, True, False)
    if res.decompiledFunction is not None:
        add_decompiler_func_info(cu, die, func, res, file_index, func_line)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines).encode(""utf8""))",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,650597d7553654cd0c643c4bfbffaf9c8d9e1b4a,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/650597d7553654cd0c643c4bfbffaf9c8d9e1b4a
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    addr_to_line = {}
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        die, func_addrs = add_function(cu, f, file_index)
        addr_to_line.update(func_addrs)

    for addr in sorted(addr_to_line):
        dwarf_add_line_entry(dbg, file_index, addr, addr_to_line[addr], 0, True, False)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    addr_to_line = {}
    for l in lines:
        for token in l.allTokens:
            if token.minAddress:
                addr_to_line[get_real_address(token.minAddress)] = l.lineNumber + func_line - 1

    return addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end - 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    if res.decompiledFunction is None:
        d = ""/* Error decompiling %s: %s */"" % (func.getName(True), res.errorMessage)
    else:
        d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    addr_to_line = {f_start: func_line}
    if res.decompiledFunction is not None:
        addr_to_line.update(add_decompiler_func_info(cu, die, func, res, file_index, func_line))

    return die, addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines).encode(""utf8""))",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8bac8691e68d4f747a599ec7ad37c68c003e1010,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/8bac8691e68d4f747a599ec7ad37c68c003e1010
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    addr_to_line = {}
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        die, func_addrs = add_function(cu, f, file_index)
        addr_to_line.update(func_addrs)

    for addr in sorted(addr_to_line):
        dwarf_add_line_entry(dbg, file_index, addr, addr_to_line[addr], 0, True, False)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    addr_to_line = {}
    for l in lines:
        for token in l.allTokens:
            if token.minAddress:
                addr_to_line[get_real_address(token.minAddress)] = l.lineNumber + func_line - 1

    return addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end + 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    if res.decompiledFunction is None:
        d = ""/* Error decompiling %s: %s */"" % (func.getName(True), res.errorMessage)
    else:
        d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line)
    addr_to_line = {f_start: func_line}
    if res.decompiledFunction is not None:
        addr_to_line.update(add_decompiler_func_info(cu, die, func, res, file_index, func_line))

    return die, addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines).encode(""utf8""))",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/8ebcc9bf613d7d5c5d7a71a3af5cb29a143786c5
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    addr_to_line = {}
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        die, func_addrs = add_function(cu, f, file_index)
        addr_to_line.update(func_addrs)

    for addr in sorted(addr_to_line):
        dwarf_add_line_entry(dbg, file_index, addr, addr_to_line[addr], 0, True, False)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    addr_to_line = {}
    for l in lines:
        for token in l.allTokens:
            if token.minAddress:
                addr_to_line[get_real_address(token.minAddress)] = l.lineNumber + func_line - 1

    return addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end + 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    if res.decompiledFunction is None:
        d = ""/* Error decompiling %s: %s */"" % (func.getName(True), res.errorMessage)
    else:
        d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line + 1)
    addr_to_line = {f_start: func_line + 1}
    if res.decompiledFunction is not None:
        addr_to_line.update(add_decompiler_func_info(cu, die, func, res, file_index, func_line))

    return die, addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines).encode(""utf8""))",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/8b7f766c415a22e80a8a2dc3df6d4b92fb6dcc14
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,add_sections_to_elf,"def add_sections_to_elf(from_file, to_file, sections):
	with open(from_file, 'rb') as f:
		bb = f.read()
	e = Elf(bb)

	for name, s in sections:
		e.add_section(name, s)
	out = e.generate_updated_elf()
	with open(to_file, 'wb') as f:
		f.write(out)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__init__,"	def __init__(self, file_offset, map, values, **kwargs):
		self.__dict__['map'] = map
		self.file_offset = file_offset
		for n, v in zip(map, values):
			if isinstance(n, tuple):
				n, f = n
				v = f(v)
			setattr(self, n, v)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,values,"	def values(self):
		vv = (getattr(self, n[0] if isinstance(n, tuple) else n) for n in self.map)
		return [v.code if isinstance(v, DumbEnumValue) else v for v in vv]",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__setattr__,"	def __setattr__(self, name, value):
		if not hasattr(self, 'repr_pos'):
			object.__setattr__(self, 'repr_pos', {})
		if name not in self.repr_pos:
			self.repr_pos[name] = len(self.repr_pos)
		return object.__setattr__(self, name, value)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__repr__,"	def __repr__(self):
		args = ', '.join('%s=%r' % (n, getattr(self, n)) for n, _ in sorted(self.repr_pos.items(), key=lambda x: x[1]))
		return '%s(%s)' % (self.__class__.__name__, args)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			'magic',
			('elf_class', ElfClass.__getitem__),
			('elf_data', ElfData.__getitem__),
			'file_version',
			'osabi',
			'abi_version',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__init__,"	def __init__(self, values, file_offset):
		return ElfBase.__init__(self, file_offset, [
			('type', ET.__getitem__),
			('machine', EM.__getitem__),
			'version',
			'entry',
			'phoff',
			'shoff',
			'flags',
			'ehsize',
			'phentsize',
			'phnum',
			'shentsize',
			'shnum',
			'shstrndx',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__init__,"	def __init__(self, values, file_offset):
		self.name = ''
		return ElfBase.__init__(self, file_offset, [
			'name_offset',
			('type', SHT.__getitem__),
			'flags',
			'addr',
			'offset',
			'section_size',
			'link',
			'info',
			'addralign',
			'entsize',
		], values)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__init__,"	def __init__(self, bytes):
		self.bytes = bytearray(bytes)
		self.extract_ident()
		bits = '64' if self.ident.elf_class == ElfClass.ELFCLASS64 else '32'
		#bits = '64' if ElfClass[self.ident.elf_class] == ElfClass.ELFCLASS64 else '32'
		endianness = 'le' if self.ident.elf_data == ElfData.ELFDATA2LSB else 'be'
		#endianness = 'le' if ElfData[self.ident.elf_data] == ElfData.ELFDATA2LSB else 'be'
		self.type = bits + endianness
		self.new_sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,_get_struct,"	def _get_struct(self, cls):
		s = struct_coders[cls.__name__]
		return s[self.type] if isinstance(s, dict) else s",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,_dump_struct,"	def _dump_struct(self, cls, off):
		s = self._get_struct(cls)
		# unpack_from doesn't work with jython
		# return cls(s.unpack_from(self.bytes, off), file_offset=off)
		bb = self.bytes[off:off+s.size]
		return cls(s.unpack(str(bb)), file_offset=off)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,_export_struct,"	def _export_struct(self, val, off):
		s = self._get_struct(val.__class__)
		# unpack_into doesn't work with jython
		# s.pack_into(self.bytes, off, *val.values)
		self.bytes[off:off+s.size] = s.pack(*val.values)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,extract_ident,"	def extract_ident(self):
		if hasattr(self, 'ident'):
			return self.ident
		self.ident = self._dump_struct(ElfIdent, 0)
		self.header_off = self._get_struct(ElfIdent).size
		return self.ident",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,extract_header,"	def extract_header(self):
		if hasattr(self, 'header'):
			return self.header
		self.header = self._dump_struct(ElfHeader, self.header_off)
		return self.header",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,extract_section_headers,"	def extract_section_headers(self):
		if hasattr(self, 'section_headers'):
			return self.section_headers

		self.section_headers = []
		h = self.extract_header()
		for i in range(h.shnum):
			self.section_headers.append(self._dump_struct(ElfSectionHeader, h.shoff + i * h.shentsize))
		self.section_names = self.extract_section(self.section_headers[h.shstrndx])
		for s in self.section_headers:
			s.name = self.section_names[s.name_offset:self.section_names.find('\x00', s.name_offset)]
		return self.section_headers",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,extract_section,"	def extract_section(self, section_header):
		return self.bytes[section_header.offset:section_header.offset+section_header.section_size]",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,encode_section_header,"	def encode_section_header(self, section_header):
		return self._get_struct(ElfSectionHeader).pack(*section_header.values)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,add_section,"	def add_section(self, name, body):
		self.new_sections.append((name, body))",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,generate_updated_elf,"	def generate_updated_elf(self):
		section_headers = self.extract_section_headers()
		added_sections = False
		for name, body in self.new_sections:
			try:
				s = next(s for s in section_headers if s.name == name)
			except:
				added_sections = True
				name_off = len(self.section_names)
				self.section_names += name + '\x00'
				s = ElfSectionHeader([name_off, 1, 0, 0, -1, -1, 0, 0, 1, 0], file_offset=-1)
				s.name = name
				section_headers.append(s)
			s.offset = len(self.bytes)
			s.section_size = len(body)
			self.bytes += body

		h = self.header
		if added_sections:
			shstr = section_headers[h.shstrndx]
			shstr.section_size = len(self.section_names)
			shstr.offset = len(self.bytes)
			self.bytes += self.section_names
			h.shoff = len(self.bytes)
			h.shnum = len(section_headers)
			self.bytes += '\x00' * h.shentsize * h.shnum

		self._export_struct(h, self.header_off)
		for i, s in enumerate(section_headers):
			s.file_offset = h.shoff + i * h.shentsize
			self._export_struct(s, s.file_offset)

		return self.bytes",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__init__,"	def __init__(self, name, code, desc): self.name, self.code, self.desc = name, code, desc",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__repr__,"	def __repr__(self): return '%s(%r, %r)' % (self.name, self.code, self.desc)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__init__,"		def __init__(cls, *args):
			cls._bycode = {}
			for n in dir(cls):
				if n[0] != '_':
					v = DumbEnumValue(n, *getattr(cls, n))
					setattr(cls, n, v)
					cls._bycode[v.code] = v",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,f58a81e89793c0924dfd5eddb70cbdf23caadd61,elf.py,__getitem__,"		def __getitem__(cls, idx):
			try:
				return cls._bycode[idx]
			except KeyError:
				return DumbEnumValue(""%s_%s"" % (cls.__name__, idx), idx, ""Unknown entry %d"" % idx)",https://www.github.com/cesena/ghidra2dwarf/commit/f58a81e89793c0924dfd5eddb70cbdf23caadd61
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,get_real_address,"def get_real_address(addr):
    return addr.offset - image_base + orig_base",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,get_libdwarf_err,"def get_libdwarf_err():
    derr = Dwarf_Error(err.value)
    print(derr)
    return dwarf_errmsg(derr)",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,generate_fun_wrapper,"def generate_fun_wrapper(name, fun):
    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r

    return wrapper",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_debug_info,"def add_debug_info():
    dwarf_pro_set_default_string_form(dbg, DW_FORM_string)
    cu = dwarf_new_die(dbg, DW_TAG_compile_unit, None, None, None, None)

    c_file_name = os.path.split(decompiled_c_path)[1]
    dwarf_add_AT_name(cu, c_file_name)
    dir_index = dwarf_add_directory_decl(dbg, ""."")
    file_index = dwarf_add_file_decl(dbg, c_file_name, dir_index, 0, 0)
    dwarf_add_AT_comp_dir(cu, ""."")

    funcs = get_functions()
    addr_to_line = {}
    max_addr = 0
    for i, f in enumerate(funcs):
        print(""Decompiling function %d: %s"" % (i, f))
        die, func_addrs = add_function(cu, f, file_index)
        addr_to_line.update(func_addrs)
        max_addr = max(max_addr, get_function_range(f)[1] + 1)

    for addr in sorted(addr_to_line):
        dwarf_add_line_entry(dbg, file_index, addr, addr_to_line[addr], 0, True, False)
        max_addr = max(max_addr, addr + 1)

    dwarf_lne_end_sequence_a(dbg, max_addr)

    dwarf_add_die_to_debug_a(dbg, cu)
    add_global_variables(cu)
    add_structures(cu)",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,generate_register_mappings,"def generate_register_mappings():
    d2g_mapping = DWARFRegisterMappingsManager.getMappingForLang(curr.language)
    g2d_mapping = {}
    for i in range(DW_FRAME_LAST_REG_NUM):
        reg = d2g_mapping.getGhidraReg(i)
        if reg:
            g2d_mapping[reg.offset] = i
    stack_reg_num = d2g_mapping.DWARFStackPointerRegNum
    stack_reg_dwarf = globals()[""DW_OP_breg%d"" % stack_reg_num]
    return g2d_mapping, stack_reg_dwarf",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,generate_decomp_interface,"def generate_decomp_interface():
    decompiler = DecompInterface()
    opts = DecompileOptions()
    opts.grabFromProgram(curr)
    decompiler.setOptions(opts)
    decompiler.toggleCCode(True)
    decompiler.toggleSyntaxTree(True)

    # - decompile -- The main decompiler action
    # - normalize -- Decompilation tuned for normalization
    # - jumptable -- Simplify just enough to recover a jump-table
    # - paramid   -- Simplify enough to recover function parameters
    # - register  -- Perform one analysis pass on registers, without stack variables
    # - firstpass -- Construct the initial raw syntax tree, with no simplification
    decompiler.setSimplificationStyle(""decompile"")
    decompiler.openProgram(curr)
    return decompiler",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,get_decompiled_function,"def get_decompiled_function(func):
    return decompiler.decompileFunction(func, 0, monitor)",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,get_decompiled_variables,"def get_decompiled_variables(decomp):
    hf = decomp.highFunction
    symbolMap = hf.localSymbolMap
    params = [symbolMap.getParam(i).symbol for i in range(symbolMap.numParams) if symbolMap.getParam(i)]
    for s in symbolMap.symbols:
        yield s.name, s.dataType, s.PCAddress, s.storage, s in params",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_decompiler_func_info,"def add_decompiler_func_info(cu, func_die, func, decomp, file_index, func_line):
    # https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompileResults.html
    # print(func.allVariables)
    for name, datatype, addr, storage, is_param in get_decompiled_variables(decomp):
        add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=is_param)

    cmarkup = decomp.CCodeMarkup
    # TODO: implement our own pretty printer?
    # https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
    lines = DecompilerUtils.toLines(cmarkup)
    addr_to_line = {}
    for l in lines:
        for token in l.allTokens:
            if token.minAddress:
                addr_to_line[get_real_address(token.minAddress)] = l.lineNumber + func_line - 1

    return addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,get_functions,"def get_functions():
    fm = curr.functionManager
    funcs = fm.getFunctions(True)
    return funcs",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,get_function_range,"def get_function_range(func):
    return get_real_address(func.entryPoint), get_real_address(func.body.maxAddress)",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,is_function_executable,"def is_function_executable(func):
    f_start, f_end = get_function_range(func)
    # Check for functions inside executable segments
    for s in curr.memory.executeSet.addressRanges:
        if f_start >= get_real_address(s.minAddress) and f_end <= get_real_address(s.maxAddress):
            return True
    return False",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_global_variables,"def add_global_variables(cu):
    for s in curr.symbolTable.getAllSymbols(True):
        # TODO: What is the difference between GLOBAL and GLOBAL_VAR ?
        if s.symbolType in [SymbolType.LABEL, SymbolType.GLOBAL, SymbolType.GLOBAL_VAR]:
            t = curr.listing.getDataAt(s.address)
            if t:
                die = dwarf_new_die(dbg, DW_TAG_variable, cu, None, None, None)
                var_type_die = add_type(cu, t.dataType)

                dwarf_add_AT_name(die, s.name)
                dwarf_add_AT_reference(dbg, die, DW_AT_type, var_type_die)

                loc_expr = dwarf_new_expr(dbg)
                dwarf_add_expr_addr_b(loc_expr, get_real_address(t.address), 0)
                dwarf_add_AT_location_expr(dbg, die, DW_AT_location, loc_expr)",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_structures,"def add_structures(cu):
    for s in curr.dataTypeManager.allStructures:
        add_type(cu, s)",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_variable,"def add_variable(cu, func_die, name, datatype, addr, storage, is_parameter=False):
    # TODO: there could be more than one varnode, what does it even mean?
    varnode = storage.firstVarnode
    # It looks like sometimes ghidra creates a fake/temp variable without any varnodes, it should be ok to ignore it
    if varnode is None:
        return None
    varnode_addr = varnode.getAddress()

    # TODO: add varaible starting from addr
    tag = DW_TAG_variable
    if is_parameter:
        tag = DW_TAG_formal_parameter
    var_die = dwarf_new_die(dbg, tag, func_die, None, None, None)
    type_die = add_type(cu, datatype)

    dwarf_add_AT_reference(dbg, var_die, DW_AT_type, type_die)
    dwarf_add_AT_name(var_die, name)

    expr = dwarf_new_expr(dbg)

    try:
        if varnode_addr.isRegisterAddress():
            reg = curr.getRegister(varnode_addr, varnode.size)
            reg_dwarf = register_mappings[reg.offset]
            dwarf_add_expr_gen(expr, DW_OP_regx, reg_dwarf, 0)
        elif varnode_addr.isStackAddress():
            # TODO: properly get register size and figure out if this is always correct
            dwarf_add_expr_gen(expr, DW_OP_fbreg, varnode_addr.offset - varnode_addr.pointerSize, 0)
        elif varnode_addr.isMemoryAddress():
            print(name, varnode)
            # TODO: globals?
            assert False, ""Memory address""
        elif varnode_addr.isHashAddress():
            # TODO: ghidra synthetic vars.
            # It however often can be linked to a register(/stack off?) if looking at the disass,
            # find, if possible, how to get it programmatically.
            # This info is likely lost when generating the decompiled code. :(
            # print('hash', varnode, curr.getRegister(varnode_addr, varnode.size))
            pass
        else:
            assert False, (""ERR var:"", varnode)

        dwarf_add_AT_location_expr(dbg, var_die, DW_AT_location, expr)
    except:
        return var_die
    return var_die",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_function,"def add_function(cu, func, file_index):
    die = dwarf_new_die(dbg, DW_TAG_subprogram, cu, None, None, None)
    loc_expr = dwarf_new_expr(dbg)
    dwarf_add_expr_gen(loc_expr, DW_OP_call_frame_cfa, 0, 0)
    dwarf_add_AT_location_expr(dbg, die, DW_AT_frame_base, loc_expr)
    f_name = func.name
    dwarf_add_AT_name(die, f_name)
    dwarf_add_AT_string(dbg, die, DW_AT_linkage_name, f_name)

    # TODO: Check for multiple ranges
    f_start, f_end = get_function_range(func)

    ret_type_die = add_type(cu, func.returnType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, ret_type_die)

    dwarf_add_AT_targ_address(dbg, die, DW_AT_low_pc, f_start, 0)
    dwarf_add_AT_targ_address(dbg, die, DW_AT_high_pc, f_end + 1, 0)

    func_line = len(decomp_lines) + 1

    res = get_decompiled_function(func)
    if res.decompiledFunction is None:
        d = ""/* Error decompiling %s: %s */"" % (func.getName(True), res.errorMessage)
    else:
        d = res.decompiledFunction.c
    decomp_lines.extend(d.split(""\n""))

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_file, file_index)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_decl_line, func_line + 1)
    addr_to_line = {f_start: func_line + 1}
    if res.decompiledFunction is not None:
        addr_to_line.update(add_decompiler_func_info(cu, die, func, res, file_index, func_line))

    return die, addr_to_line",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,write_source,"def write_source():
    with open(decompiled_c_path, ""wb"") as src:
        src.write(""\n"".join(decomp_lines).encode(""utf8""))",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_type,"def add_type(cu, t):
    if t.name in record:
        return record[t.name]

    if isinstance(t, Pointer):
        return add_ptr_type(cu, t)
    elif isinstance(t, Enum):
        return add_enum_type(cu, t)
    elif isinstance(t, Array):
        return add_array_type(cu, t)
    elif isinstance(t, Structure):
        return add_struct_type(cu, t)
    elif isinstance(t, (BuiltInDataType, DefaultDataType)):
        return add_default_type(cu, t)
    else:
        try:
            return add_default_type(cu, t)
        except:
            assert False, (""ERR type:"", type(t), t)
        return None",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_default_type,"def add_default_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_base_type, cu, None, None, None)
    record[t.name] = die
    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    # type encoding dwarfstd.org/doc/DWARF4.pdf#page=91
    if isinstance(t, BooleanDataType):
        encoding = DW_ATE_boolean
    elif isinstance(t, CharDataType):
        is_char_signed = t.dataTypeManager.dataOrganization.signedChar
        encoding = DW_ATE_signed_char if is_char_signed else DW_ATE_unsigned_char
    elif isinstance(t, AbstractIntegerDataType):
        encoding = DW_ATE_signed if t.signed else DW_ATE_unsigned
    elif isinstance(t, AbstractFloatDataType):
        encoding = DW_ATE_float
    elif isinstance(t, AbstractComplexDataType):
        encoding = DW_ATE_complex_float
    else:
        # if I forgot a type it's probably ok for it to be encoded as an unsigned integer
        encoding = DW_ATE_unsigned
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, encoding)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_ptr_type,"def add_ptr_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_pointer_type, cu, None, None, None)
    record[t.name] = die

    # Some pointer don't have childs
    if t.dataType:
        child_die = add_type(cu, t.dataType)
        dwarf_add_AT_reference(dbg, die, DW_AT_type, child_die)

    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_encoding, DW_ATE_address)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_enum_type,"def add_enum_type(cu, t):
    die = dwarf_new_die(dbg, DW_TAG_enumeration_type, cu, None, None, None)
    record[t.name] = die

    dwarf_add_AT_name(die, t.name)
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, t.length)

    int_type = AbstractIntegerDataType.getUnsignedDataType(t.length, curr.dataTypeManager)
    child_type_die = add_type(cu, int_type)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, child_type_die)

    # In this way we iterate the values in order
    for value in t.values:
        name = t.getName(value)
        child_die = dwarf_new_die(dbg, DW_TAG_enumerator, die, None, None, None)
        dwarf_add_AT_name(child_die, name)
        dwarf_add_AT_unsigned_const(dbg, child_die, DW_AT_const_value, value)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_struct_type,"def add_struct_type(cu, struct):
    die = dwarf_new_die(dbg, DW_TAG_structure_type, cu, None, None, None)
    record[struct.name] = die
    dwarf_add_AT_name(die, struct.name.replace(""struct"", """"))
    dwarf_add_AT_unsigned_const(dbg, die, DW_AT_byte_size, struct.length)
    for c in struct.components:
        member_die = dwarf_new_die(dbg, DW_TAG_member, die, None, None, None)
        member_type_die = add_type(cu, c.dataType)
        dwarf_add_AT_reference(dbg, member_die, DW_AT_type, member_type_die)
        dwarf_add_AT_name(member_die, c.fieldName or c.defaultFieldName)

        loc_expr = dwarf_new_expr(dbg)
        dwarf_add_expr_gen(loc_expr, DW_OP_plus_uconst, c.offset, 0)

        dwarf_add_AT_location_expr(dbg, member_die, DW_AT_data_member_location, loc_expr)
    return die",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,add_array_type,"def add_array_type(cu, array):
    die = dwarf_new_die(dbg, DW_TAG_array_type, cu, None, None, None)
    record[array.name] = die

    element_die = add_type(cu, array.dataType)
    dwarf_add_AT_reference(dbg, die, DW_AT_type, element_die)

    subrange = dwarf_new_die(dbg, DW_TAG_subrange_type, die, None, None, None)
    # array.length is the total size of the array, so we need to divide it with
    # the dataType's length to find the number of elements
    dwarf_add_AT_unsigned_const(dbg, subrange, DW_AT_count, array.length / array.dataType.length)

    return die",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,generate_dwarf_sections,"def generate_dwarf_sections():
    section_count = dwarf_transform_to_disk_form(dbg)
    print(""section_count"", section_count)

    sections = {}
    for i in xrange(section_count):
        section_index = LongByReference()
        length = LongByReference()
        content = dwarf_get_section_bytes(dbg, i, section_index, length)

        section_index = section_index.value
        length = length.value
        content = bytearray(content.getByteArray(0, length))
        section_name = sections_callback.sections[section_index]
        if section_name not in sections:
            sections[section_name] = """"
        sections[section_name] += content
        print(section_index, section_name, length)
    return sections.items()",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,wrapper,"    def wrapper(*args):
        r = fun(*(args + (err,)))
        error_check = DWARF_FUNCTIONS[name]
        if error_check(r):
            # TODO: dwarf_errmsg (hence get_libdwarf_err) is broken for some reason
            # assert False, ""%s failed: %s"" % (name, get_libdwarf_err())
            assert False, ""%s failed. Returned %r"" % (name, r)
        return r",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,__init__,"    def __init__(self):
        self.sections = []",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
master,07260205e9d73b21146a7cbf1244aa5030540183,ghidra2dwarf.py,apply,"    def apply(self, name, *args):
        name = str(name.getString(0))
        print(""info_callback"", name)
        self.sections.append(name)
        return len(self.sections) - 1",https://www.github.com/cesena/ghidra2dwarf/commit/07260205e9d73b21146a7cbf1244aa5030540183
